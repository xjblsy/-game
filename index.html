<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Deep Sea Evolution: Ultimate</title>
    <style>
        /* --- æ ¸å¿ƒæ ·å¼ --- */
        :root {
            --neon-blue: #00f2fe;
            --neon-gold: #ffd700;
            --neon-red: #ff0055;
            --glass: rgba(12, 20, 35, 0.95);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; font-family: 'Segoe UI', sans-serif; }
        
        body { 
            background: #000; overflow: hidden; width: 100vw; height: 100vh; 
            display: flex; justify-content: center; align-items: center; color: #fff;
        }

        canvas { position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* UI å±‚çº§å¿…é¡»é«˜äº Canvas */
        #ui-layer { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 100; 
            pointer-events: none; /* å…è®¸ç‚¹å‡»ç©¿é€åˆ°æ¸¸æˆ */
        }

        /* äº¤äº’é¢æ¿ (å…è®¸ç‚¹å‡») */
        .panel {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: var(--glass);
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 0 50px rgba(0,0,0,0.8), inset 0 0 20px rgba(0, 242, 254, 0.05);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            min-width: 420px;
            pointer-events: auto;
            display: none;
            opacity: 0; transition: opacity 0.3s ease;
        }

        .panel.active { display: block; opacity: 1; }

        h1 {
            font-size: 2.2rem; margin-bottom: 20px;
            background: linear-gradient(to right, #fff, var(--neon-blue));
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            text-shadow: 0 0 20px rgba(0, 242, 254, 0.4);
        }

        input {
            background: rgba(0,0,0,0.5); border: 2px solid #333;
            color: #fff; padding: 15px; width: 100%; border-radius: 10px;
            font-size: 1.2rem; text-align: center; margin-bottom: 20px; outline: none;
            transition: 0.3s;
        }
        input:focus { border-color: var(--neon-blue); box-shadow: 0 0 15px rgba(0,242,254,0.2); }

        .btn {
            background: linear-gradient(135deg, #0061ff, #60efff);
            border: none; padding: 12px 35px; border-radius: 50px;
            color: #000; font-weight: 900; cursor: pointer;
            font-size: 1.1rem; transition: 0.2s;
            box-shadow: 0 5px 15px rgba(0, 242, 254, 0.3);
        }
        .btn:hover { transform: scale(1.05); filter: brightness(1.1); }
        .btn-outline { background: transparent; border: 2px solid rgba(255,255,255,0.2); color: #fff; box-shadow: none; }
        .btn-outline:hover { border-color: #fff; background: rgba(255,255,255,0.1); }

        /* å­˜æ¡£åˆ—è¡¨ */
        .slot-list { margin: 20px 0; max-height: 200px; overflow-y: auto; }
        .slot-item {
            background: rgba(255,255,255,0.05); padding: 12px; margin-bottom: 8px;
            border-radius: 8px; display: flex; justify-content: space-between; align-items: center;
            border: 1px solid transparent; cursor: pointer; transition: 0.2s;
        }
        .slot-item:hover { border-color: var(--neon-blue); background: rgba(0, 242, 254, 0.1); }
        .slot-info { text-align: left; }
        .del-btn { color: var(--neon-red); font-weight: bold; padding: 5px 10px; }
        .del-btn:hover { background: rgba(255,0,0,0.1); border-radius: 5px; }

        /* HUD */
        #hud { display: none; }
        .hud-top { position: absolute; top: 20px; left: 20px; display: flex; gap: 15px; }
        .stat-box { 
            background: rgba(0,0,0,0.6); padding: 8px 16px; border-radius: 20px; 
            border: 1px solid rgba(255,255,255,0.1); font-weight: bold; 
            display: flex; align-items: center; gap: 6px;
        }

        /* æŠ€èƒ½æ  */
        .skill-bar {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 15px; pointer-events: auto;
        }
        .skill-slot {
            width: 65px; height: 65px; background: rgba(0,0,0,0.8);
            border: 2px solid #444; border-radius: 14px; position: relative;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            overflow: hidden; transition: 0.2s;
        }
        .skill-slot.ready { border-color: var(--neon-gold); box-shadow: 0 0 15px rgba(255,215,0,0.3); }
        .skill-icon { font-size: 1.4rem; z-index: 2; }
        .skill-key { font-size: 0.7rem; color: #888; margin-top: 2px; z-index: 2; font-weight: bold; }
        .cd-mask { 
            position: absolute; bottom: 0; left: 0; width: 100%; height: 0%; 
            background: rgba(0,0,0,0.7); z-index: 1; transition: height 0.1s linear; 
        }

        /* æµ®åŠ¨æ–‡å­— */
        .float-text {
            position: absolute; font-weight: 900; font-size: 1.4rem; pointer-events: none;
            text-shadow: 0 2px 5px #000; animation: floatUp 0.8s forwards;
        }
        @keyframes floatUp { to { transform: translateY(-50px); opacity: 0; } }
        
        /* éœ‡åŠ¨åé¦ˆ */
        .shake { animation: shake 0.4s ease-in-out; }
        @keyframes shake { 0%,100%{transform:translateX(0)} 25%{transform:translateX(-5px)} 75%{transform:translateX(5px)} }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div id="p-pass" class="panel active">
            <h1>SECURITY CHECK</h1>
            <p>è¾“å…¥æœ€é«˜æƒé™å¯†é’¥</p>
            <input type="password" id="inp-pass" placeholder="Password">
            <button class="btn" onclick="App.verifyPass()">ACCESS</button>
            <p id="err-msg" style="color: var(--neon-red); margin-top: 15px; display: none;">å¯†é’¥æ— æ•ˆ</p>
        </div>

        <div id="p-login" class="panel">
            <h1>IDENTITY</h1>
            <p>è¾“å…¥ä»£å· (æ‹¼éŸ³é¦–å­—æ¯)</p>
            <input type="text" id="inp-user" maxlength="8" placeholder="ä¾‹å¦‚: LZY">
            <button class="btn" onclick="App.login()">CONNECT</button>
        </div>

        <div id="p-saves" class="panel">
            <h1>ARCHIVES</h1>
            <p id="welcome-msg"></p>
            <div class="slot-list" id="slot-container"></div>
            <div style="display: flex; justify-content: center; gap: 15px; margin-top: 20px;">
                <button class="btn" onclick="App.newGame()">æ–°å¾ç¨‹</button>
                <button class="btn btn-outline" onclick="App.logout()">é€€å‡º</button>
            </div>
        </div>

        <div id="p-inter" class="panel">
            <h1 style="color: var(--neon-gold);">VICTORY</h1>
            <p>å½“å‰åŒºåŸŸå·²å¾æœ</p>
            <div style="background:rgba(255,255,255,0.05); padding:15px; border-radius:10px; text-align:left; margin:20px 0;">
                <p style="margin:0; color:#fff;">ä¸‹ä¸€ç«™: <span style="color:var(--neon-red); font-weight:bold;">æ·±æ¸Šç¦åŒº</span></p>
                <p style="font-size:0.9rem; margin-top:5px;">è­¦å‘Š: æåº¦é»‘æš—ï¼Œæ£€æµ‹åˆ°å·¨å‹ç”Ÿç‰©ååº”ã€‚</p>
            </div>
            <button class="btn" onclick="App.nextLevel()">æ½œå…¥æ·±æ¸Š</button>
            <button class="btn btn-outline" onclick="App.saveQuit()">å­˜æ¡£ä¼‘æ¯</button>
        </div>

        <div id="p-over" class="panel">
            <h1 style="color: var(--neon-red);">M.I.A.</h1>
            <p>ä¿¡å·ä¸­æ–­...</p>
            <button class="btn" onclick="Game.retry()">é‡ç½®åŸºå› </button>
            <button class="btn btn-outline" onclick="App.toSaves()">è¿”å›</button>
        </div>

        <div id="hud">
            <div class="hud-top">
                <div class="stat-box" style="border-color: var(--neon-red); color: var(--neon-red);">
                    â¤ <span id="ui-lives">3</span>
                </div>
                <div class="stat-box" style="border-color: var(--neon-blue); color: var(--neon-blue);">
                    ğŸ“ <span id="ui-size">0</span> / <span id="ui-target">0</span>
                </div>
                <div class="stat-box">
                    âš“ <span id="ui-level">Zone 1</span>
                </div>
            </div>

            <div class="skill-bar">
                <div class="skill-slot" id="s-dash">
                    <div class="skill-icon">âš¡</div>
                    <div class="skill-key">SPACE</div>
                    <div class="cd-mask" id="cd-dash"></div>
                </div>
                <div class="skill-slot" id="s-shield">
                    <div class="skill-icon">ğŸ›¡ï¸</div>
                    <div class="skill-key">J</div>
                    <div class="cd-mask" id="cd-shield"></div>
                </div>
                <div class="skill-slot" id="s-magnet">
                    <div class="skill-icon">ğŸ§²</div>
                    <div class="skill-key">K</div>
                    <div class="cd-mask" id="cd-magnet"></div>
                </div>
                <div class="skill-slot" id="s-sonar" style="display:none;">
                    <div class="skill-icon">ğŸ“¡</div>
                    <div class="skill-key">L</div>
                    <div class="cd-mask" id="cd-sonar"></div>
                </div>
            </div>
        </div>
    </div>

<script>
/**
 * --- å®‰å…¨å­˜å‚¨å±‚ (è§£å†³æœ¬åœ°è¿è¡ŒæŠ¥é”™çš„æ ¸å¿ƒ) ---
 * å¦‚æœ localStorage ä¸å¯ç”¨ï¼ˆå¦‚ç›´æ¥è¿è¡Œ HTMLï¼‰ï¼Œè‡ªåŠ¨åˆ‡æ¢åˆ°å†…å­˜å­˜å‚¨
 */
const SafeStorage = {
    _mem: {},
    isAvailable: false,
    init() {
        try {
            localStorage.setItem('test', '1');
            localStorage.removeItem('test');
            this.isAvailable = true;
        } catch(e) {
            console.warn("Storage restricted. Using memory mode.");
            this.isAvailable = false;
        }
    },
    getItem(k) {
        if(this.isAvailable) return localStorage.getItem(k);
        return this._mem[k] || null;
    },
    setItem(k, v) {
        if(this.isAvailable) localStorage.setItem(k, v);
        else this._mem[k] = v;
    }
};
SafeStorage.init();

/* --- æ¸¸æˆé…ç½® --- */
const CFG = {
    Pass: 'xjblsy99',
    Levels: [
        { id:0, name:"é˜³å…‰æµ…æ»©", target:60, startR:15, dark:0, skills:['dash','shield','magnet'], bg:['#006994','#003366'], spawns:['tetra','goldie','ray'] },
        { id:1, name:"æ·±æ¸Šç¦åŒº", target:200, startR:65, dark:0.92, skills:['dash','shield','magnet','sonar'], bg:['#090909','#1a0b2e'], spawns:['goldie','angler','shark','whale'] }
    ],
    Fish: {
        tetra: { r:[5,12], spd:2.5, color:'#ff00cc', type:'neon' },
        goldie: { r:[12,25], spd:1.8, color:'#ff9f43', type:'gold' },
        ray: { r:[20,35], spd:2.2, color:'#00d2d3', type:'flat' },
        angler: { r:[35,55], spd:1.4, color:'#a55eea', type:'angler' },
        shark: { r:[50,80], spd:3.5, color:'#576574', type:'shark', aggro:true },
        whale: { r:[90,150], spd:0.8, color:'#2f3542', type:'whale' }
    },
    Skills: {
        dash: { cd:3000, dur:300, color:'#00f2fe' },
        shield: { cd:12000, dur:3000, color:'#ffd700' },
        magnet: { cd:15000, dur:4000, color:'#bd00ff', r:350 },
        sonar: { cd:20000, dur:100, color:'#fff', r:1000 }
    }
};

/* --- æ¸²æŸ“å¼•æ“ (Visuals) --- */
const Renderer = {
    drawFish(ctx, x, y, r, angle, color, type, phase) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);

        // é¢œè‰²å¤„ç†
        const grad = ctx.createRadialGradient(0, -r*0.3, r*0.1, 0, 0, r);
        grad.addColorStop(0, '#fff'); // é«˜å…‰
        grad.addColorStop(0.3, color);
        grad.addColorStop(1, '#000'); // é˜´å½±

        const swing = Math.sin(phase);

        // 1. ç»˜åˆ¶å°¾å·´ (éª¨éª¼åŠ¨ç”»)
        ctx.fillStyle = color;
        ctx.beginPath();
        if(type === 'shark') {
            // é²¨é±¼å°¾ (å¼ºåŠ²)
            ctx.moveTo(-r*0.8, 0);
            ctx.quadraticCurveTo(-r*1.5, swing*r*0.4, -r*2.2, -r*0.8 + swing*r*0.8);
            ctx.lineTo(-r*2.2, r*0.8 + swing*r*0.8);
            ctx.quadraticCurveTo(-r*1.5, swing*r*0.4, -r*0.8, 0);
        } else if(type === 'whale') {
            // é²¸é±¼å°¾ (ä¸Šä¸‹æ‘†åŠ¨æ¨¡æ‹Ÿ)
            ctx.moveTo(-r*0.9, 0);
            ctx.quadraticCurveTo(-r*1.8, 0, -r*2.4, -r*0.7 + swing*r*0.2);
            ctx.lineTo(-r*2.4, r*0.7 + swing*r*0.2);
            ctx.quadraticCurveTo(-r*1.8, 0, -r*0.9, 0);
        } else {
            // æ™®é€šé±¼å°¾
            ctx.moveTo(-r*0.7, 0);
            ctx.lineTo(-r*1.5, -r*0.6 + swing*10);
            ctx.lineTo(-r*1.5, r*0.6 + swing*10);
        }
        ctx.fill();

        // 2. ä¾§é³
        const finAngle = Math.PI/4 + Math.sin(phase)*0.2;
        ctx.beginPath();
        ctx.ellipse(r*0.2, r*0.6, r*0.3, r*0.15, finAngle, 0, Math.PI*2);
        ctx.ellipse(r*0.2, -r*0.6, r*0.3, r*0.15, -finAngle, 0, Math.PI*2);
        ctx.fillStyle = color;
        ctx.fill();

        // 3. èº«ä½“
        ctx.beginPath();
        if(type === 'shark') ctx.ellipse(0, 0, r*1.2, r*0.6, 0, 0, Math.PI*2);
        else if(type === 'whale') ctx.ellipse(0, 0, r*1.1, r*0.8, 0, 0, Math.PI*2);
        else ctx.ellipse(0, 0, r, r*0.75, 0, 0, Math.PI*2);
        ctx.fillStyle = grad;
        ctx.fill();

        // 4. çº¹ç†/é³ç‰‡ (High Quality Detail)
        ctx.strokeStyle = 'rgba(0,0,0,0.2)';
        ctx.lineWidth = 1;
        if(type === 'goldie') {
            // é³ç‰‡æ•ˆæœ
            for(let i=0; i<3; i++) {
                ctx.beginPath(); ctx.arc(-r*0.3 + i*10, 0, r*0.4, -0.5, 0.5); ctx.stroke();
            }
        } else if(type === 'neon' || type === 'player') {
            // éœ“è™¹æ¡çº¹
            ctx.strokeStyle = 'rgba(255,255,255,0.4)';
            ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(-r*0.5, 0); ctx.lineTo(r*0.5, 0); ctx.stroke();
        }

        // 5. çœ¼ç›
        const eyeX = r*0.4, eyeY = r*0.35, eyeSz = r*0.22;
        ctx.fillStyle = '#fff';
        ctx.beginPath(); ctx.arc(eyeX, -eyeY, eyeSz, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(eyeX, eyeY, eyeSz, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#000';
        ctx.beginPath(); ctx.arc(eyeX+1, -eyeY, eyeSz*0.5, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(eyeX+1, eyeY, eyeSz*0.5, 0, Math.PI*2); ctx.fill();

        // 6. ç¯ç¬¼é±¼ç‰¹ä¾›
        if(type === 'angler') {
            ctx.beginPath();
            ctx.moveTo(r*0.5, -r*0.2);
            ctx.bezierCurveTo(r*0.8, -r*1.5, r*1.2, -r*1.5, r*1.6, -r*1.2);
            ctx.strokeStyle = '#888'; ctx.lineWidth = 2; ctx.stroke();
            
            // å‘å…‰çƒ
            const pulse = 1 + Math.sin(Date.now()/200)*0.2;
            ctx.fillStyle = '#ffff00';
            ctx.shadowBlur = 15 * pulse; ctx.shadowColor = '#ffff00';
            ctx.beginPath(); ctx.arc(r*1.6, -r*1.2, 5, 0, Math.PI*2); ctx.fill();
            ctx.shadowBlur = 0;
        }

        ctx.restore();
    }
};

/* --- æ¸¸æˆå¼•æ“ --- */
const Game = {
    cvs: document.getElementById('gameCanvas'),
    ctx: document.getElementById('gameCanvas').getContext('2d'),
    W: 0, H: 0,
    state: 'STOP',
    
    player: {
        x:0, y:0, vx:0, vy:0, r:0, angle:0, tail:0, lives:3, invincible:0,
        skills: { dash:{cd:0,active:false}, shield:{cd:0,active:false}, magnet:{cd:0,active:false}, sonar:{cd:0,active:false} }
    },
    
    enemies: [],
    particles: [],
    keys: {},
    levelIdx: 0,
    saveId: null,
    camShake: 0,

    init() {
        this.resize();
        window.addEventListener('resize', () => this.resize());
        window.addEventListener('keydown', e => {
            this.keys[e.key] = true;
            if(this.state==='PLAY') this.handleSkills(e.code);
            // å›è½¦é”®æ”¯æŒ
            if(e.key === 'Enter') {
                if(UI.pPass.classList.contains('active')) App.verifyPass();
                else if(UI.pLogin.classList.contains('active')) App.login();
            }
        });
        window.addEventListener('keyup', e => this.keys[e.key] = false);
    },

    resize() {
        this.W = window.innerWidth;
        this.H = window.innerHeight;
        this.cvs.width = this.W;
        this.cvs.height = this.H;
    },

    start(lvlIdx, saveId) {
        this.levelIdx = lvlIdx;
        this.saveId = saveId;
        const cfg = CFG.Levels[lvlIdx];

        // é‡ç½®ç©å®¶
        const p = this.player;
        p.x = this.W/2; p.y = this.H/2; p.vx = 0; p.vy = 0;
        p.r = cfg.startR; p.lives = 3; p.invincible = 0;
        
        // é‡ç½®æŠ€èƒ½
        for(let k in p.skills) { p.skills[k].cd=0; p.skills[k].active=false; }
        
        this.enemies = [];
        this.particles = [];
        this.state = 'PLAY';
        
        UI.showHUD(cfg);
        this.loop();
    },

    handleSkills(code) {
        if(code==='Space') this.cast('dash');
        if(code==='KeyJ') this.cast('shield');
        if(code==='KeyK') this.cast('magnet');
        if(code==='KeyL') this.cast('sonar');
    },

    cast(key) {
        const lvl = CFG.Levels[this.levelIdx];
        if(!lvl.skills.includes(key)) return;
        
        const s = this.player.skills[key];
        const sc = CFG.Skills[key];
        
        if(s.cd <= 0 && !s.active) {
            s.active = true;
            s.cd = sc.cd;
            
            if(key === 'sonar') {
                this.camShake = 30;
                this.enemies.forEach(e => e.stunned = 180);
                UI.floatText("SONAR BLAST!", this.player.x, this.player.y-50, '#fff');
            } else {
                UI.floatText(key.toUpperCase(), this.player.x, this.player.y-50, sc.color);
            }
            setTimeout(() => s.active = false, sc.dur);
        }
    },

    loop() {
        if(this.state !== 'PLAY') return;
        
        this.ctx.clearRect(0,0,this.W,this.H);
        this.update();
        this.draw();
        
        requestAnimationFrame(() => this.loop());
    },

    update() {
        const p = this.player;
        const lvl = CFG.Levels[this.levelIdx];
        
        // 1. ç©å®¶ç§»åŠ¨
        let acc = 0.5;
        let maxSpd = 7 * (30/(p.r+20));
        if(p.skills.dash.active) maxSpd *= 2.5;

        if(this.keys['ArrowUp'] || this.keys['w']) p.vy -= acc;
        if(this.keys['ArrowDown'] || this.keys['s']) p.vy += acc;
        if(this.keys['ArrowLeft'] || this.keys['a']) p.vx -= acc;
        if(this.keys['ArrowRight'] || this.keys['d']) p.vx += acc;

        p.vx *= 0.95; p.vy *= 0.95;
        const spd = Math.sqrt(p.vx**2 + p.vy**2);
        if(spd > maxSpd) { p.vx = (p.vx/spd)*maxSpd; p.vy = (p.vy/spd)*maxSpd; }

        p.x += p.vx; p.y += p.vy;
        p.tail += 0.2 + spd*0.05;

        // è¾¹ç•Œå¤„ç†
        if(p.x < p.r) p.x=p.r; if(p.x > this.W-p.r) p.x=this.W-p.r;
        if(p.y < p.r) p.y=p.r; if(p.y > this.H-p.r) p.y=this.H-p.r;
        if(spd > 0.1) p.angle = Math.atan2(p.vy, p.vx);

        // 2. æ•Œäººç®¡ç†
        if(this.enemies.length < 18 && Math.random() < 0.02) this.spawn(lvl);

        this.enemies.forEach((e, i) => {
            // AI
            if(e.stunned > 0) {
                e.stunned--; e.vx *= 0.9; e.vy *= 0.9;
            } else {
                // é²¨é±¼è¿½å‡»
                if(e.aggro && !p.skills.shield.active) {
                    const dx = p.x - e.x, dy = p.y - e.y;
                    const d = Math.sqrt(dx*dx + dy*dy);
                    if(d < 600) { e.vx += (dx/d)*0.2; e.vy += (dy/d)*0.2; }
                }
                // ç£å¸
                if(p.skills.magnet.active && e.r < p.r) {
                    const dx = p.x - e.x, dy = p.y - e.y;
                    const d = Math.sqrt(dx*dx + dy*dy);
                    if(d < CFG.Skills.magnet.r) { e.vx += (dx/d)*0.8; e.vy += (dy/d)*0.8; }
                }
                e.x += e.vx; e.y += e.vy;
            }

            // æ›´æ–°è§’åº¦
            const espd = Math.sqrt(e.vx**2 + e.vy**2);
            e.tail += 0.15 + espd*0.05;
            if(espd > 0.1) e.angle = Math.atan2(e.vy, e.vx);

            // å‡ºç•Œç§»é™¤
            if(e.x < -200 || e.x > this.W+200 || e.y < -200 || e.y > this.H+200) {
                this.enemies.splice(i, 1); return;
            }

            // ç¢°æ’
            const dist = Math.hypot(p.x - e.x, p.y - e.y);
            if(dist < p.r + e.r*0.8) {
                if(p.r > e.r*1.1) {
                    // åƒæ‰
                    this.enemies.splice(i, 1);
                    p.r += e.r * 0.08;
                    UI.floatText(`+${Math.floor(e.r)}`, e.x, e.y, '#ffd700');
                    this.explode(e.x, e.y, e.color);
                    UI.updateHUD();
                    if(p.r >= lvl.target) { this.state = 'PAUSED'; UI.showPanel('p-inter'); }
                } else if(e.r > p.r) {
                    // å—ä¼¤
                    if(p.invincible <= 0 && !p.skills.shield.active) {
                        p.lives--; p.invincible = 120; this.camShake = 20;
                        UI.floatText("å±é™©!", p.x, p.y-50, '#ff0055');
                        UI.updateHUD();
                        if(p.lives <= 0) { this.state = 'OVER'; UI.showPanel('p-over'); }
                    }
                }
            }
        });
        if(p.invincible>0) p.invincible--;

        // 3. ç²’å­
        for(let i=this.particles.length-1; i>=0; i--) {
            let pt = this.particles[i];
            pt.x += pt.vx; pt.y += pt.vy; pt.life -= 0.03;
            if(pt.life <= 0) this.particles.splice(i,1);
        }

        // 4. CDæ›´æ–°
        for(let k in p.skills) {
            if(p.skills[k].cd > 0) {
                p.skills[k].cd -= 16;
                UI.updateCD(k, p.skills[k].cd);
            }
        }
    },

    spawn(lvl) {
        const key = lvl.spawns[Math.floor(Math.random()*lvl.spawns.length)];
        const proto = CFG.Fish[key];
        const side = Math.random()>0.5;
        
        let r = proto.r[0] + Math.random()*(proto.r[1]-proto.r[0]);
        // åŠ¨æ€éš¾åº¦: ç©å®¶å¾ˆå¤§æ—¶ï¼Œå¢åŠ å¤§é±¼æ¦‚ç‡
        if(this.player.r > 100 && !proto.aggro && Math.random()<0.3) r *= 1.5;

        this.enemies.push({
            x: side ? -100 : this.W+100,
            y: Math.random()*this.H,
            vx: (side ? 1 : -1) * proto.spd,
            vy: (Math.random()-0.5)*0.5,
            r: r,
            color: proto.color,
            type: proto.type,
            aggro: proto.aggro,
            angle: 0, tail: 0, stunned: 0
        });
    },

    explode(x, y, color) {
        for(let i=0; i<8; i++) {
            this.particles.push({
                x:x, y:y, vx:(Math.random()-0.5)*10, vy:(Math.random()-0.5)*10,
                r:Math.random()*5, color:color, life:1
            });
        }
    },

    draw() {
        const ctx = this.ctx;
        const p = this.player;
        const lvl = CFG.Levels[this.levelIdx];

        // éœ‡åŠ¨
        if(this.camShake > 0) {
            ctx.translate((Math.random()-0.5)*this.camShake, (Math.random()-0.5)*this.camShake);
            this.camShake *= 0.9;
        }

        // èƒŒæ™¯
        const bg = ctx.createLinearGradient(0,0,0,this.H);
        bg.addColorStop(0, lvl.bg[0]); bg.addColorStop(1, lvl.bg[1]);
        ctx.fillStyle = bg; ctx.fillRect(0,0,this.W,this.H);

        // æ·±æµ·å…‰æ•ˆ
        if(lvl.dark > 0) {
            ctx.fillStyle = `rgba(0,0,0,${lvl.dark})`; ctx.fillRect(0,0,this.W,this.H);
            ctx.globalCompositeOperation = 'destination-out';
            
            // ç©å®¶å…‰ç¯
            let g = ctx.createRadialGradient(p.x, p.y, p.r, p.x, p.y, p.r*5+200);
            g.addColorStop(0, 'rgba(0,0,0,1)'); g.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = g; ctx.beginPath(); ctx.arc(p.x, p.y, p.r*5+200, 0, Math.PI*2); ctx.fill();

            // ç¯ç¬¼é±¼å…‰ç¯
            this.enemies.forEach(e => {
                if(e.type==='angler') {
                    let eg = ctx.createRadialGradient(e.x, e.y, e.r, e.x, e.y, e.r*4);
                    eg.addColorStop(0, 'rgba(0,0,0,1)'); eg.addColorStop(1, 'rgba(0,0,0,0)');
                    ctx.fillStyle = eg; ctx.beginPath(); ctx.arc(e.x, e.y, e.r*4, 0, Math.PI*2); ctx.fill();
                }
            });
            ctx.globalCompositeOperation = 'source-over';
        }

        // æŠ€èƒ½ç‰¹æ•ˆ
        if(p.skills.shield.active) {
            ctx.strokeStyle = '#ffd700'; ctx.lineWidth = 4; ctx.setLineDash([10,5]);
            ctx.beginPath(); ctx.arc(p.x, p.y, p.r+20, 0, Math.PI*2); ctx.stroke(); ctx.setLineDash([]);
        }
        if(p.skills.magnet.active) {
            ctx.strokeStyle = 'rgba(189,0,255,0.3)'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.arc(p.x, p.y, CFG.Skills.magnet.r, 0, Math.PI*2); ctx.stroke();
        }
        if(p.skills.sonar.active) {
            ctx.strokeStyle = '#fff'; ctx.lineWidth = 15;
            ctx.beginPath(); ctx.arc(p.x, p.y, CFG.Skills.sonar.r, 0, Math.PI*2); ctx.stroke();
        }

        // å®ä½“ç»˜åˆ¶
        this.enemies.forEach(e => Renderer.drawFish(ctx, e.x, e.y, e.r, e.angle, e.color, e.type, e.tail));
        
        if(p.invincible%10 < 5) Renderer.drawFish(ctx, p.x, p.y, p.r, p.angle, '#00f2fe', 'player', p.tail);

        // ç²’å­
        this.particles.forEach(pt => {
            ctx.globalAlpha = pt.life; ctx.fillStyle = pt.color;
            ctx.beginPath(); ctx.arc(pt.x, pt.y, pt.r, 0, Math.PI*2); ctx.fill();
        });
        ctx.globalAlpha = 1;

        ctx.setTransform(1,0,0,1,0,0);
    },
    
    retry() { this.start(this.levelIdx, this.saveId); }
};

/* --- UI æ§åˆ¶ --- */
const UI = {
    pPass: document.getElementById('p-pass'),
    pLogin: document.getElementById('p-login'),
    pSaves: document.getElementById('p-saves'),
    hud: document.getElementById('hud'),

    hideAll() { document.querySelectorAll('.panel').forEach(p => p.classList.remove('active')); },
    
    showPanel(id) { 
        this.hideAll(); 
        if(id) document.getElementById(id).classList.add('active'); 
    },

    showHUD(lvl) {
        this.hideAll();
        this.hud.style.display = 'block';
        document.getElementById('ui-level').innerText = lvl.name;
        document.getElementById('ui-target').innerText = lvl.target;
        
        ['dash','shield','magnet','sonar'].forEach(s => {
            document.getElementById(`s-${s}`).style.display = lvl.skills.includes(s) ? 'flex' : 'none';
        });
        this.updateHUD();
    },

    updateHUD() {
        document.getElementById('ui-size').innerText = Math.floor(Game.player.r);
        document.getElementById('ui-lives').innerText = Game.player.lives;
    },

    updateCD(name, cd) {
        const max = CFG.Skills[name].cd;
        const h = (cd/max)*100;
        document.getElementById(`cd-${name}`).style.height = h + '%';
        const slot = document.getElementById(`s-${name}`);
        if(cd<=0) slot.classList.add('ready'); else slot.classList.remove('ready');
    },

    floatText(txt, x, y, color) {
        const d = document.createElement('div');
        d.className = 'float-text'; d.innerText = txt;
        d.style.left = x+'px'; d.style.top = y+'px'; d.style.color = color;
        document.getElementById('ui-layer').appendChild(d);
        setTimeout(() => d.remove(), 800);
    }
};

/* --- App æµç¨‹ --- */
const App = {
    user: null,
    
    verifyPass() {
        const v = document.getElementById('inp-pass').value;
        if(v === CFG.Pass) UI.showPanel('p-login');
        else {
            const err = document.getElementById('err-msg');
            err.style.display = 'block';
            document.getElementById('inp-pass').value = '';
        }
    },

    login() {
        const v = document.getElementById('inp-user').value.toUpperCase().trim();
        if(v && /^[A-Z]+$/.test(v)) {
            this.user = v;
            this.loadSaves();
        } else alert("è¯·è¾“å…¥æœ‰æ•ˆçš„ä»£å·ï¼ˆå­—æ¯ï¼‰");
    },

    loadSaves() {
        UI.showPanel('p-saves');
        this.hudHidden = true;
        document.getElementById('welcome-msg').innerText = `æŒ‡æŒ¥å®˜ ${this.user}`;
        const list = document.getElementById('slot-container');
        list.innerHTML = '';
        
        const saves = this.getStorage();
        if(saves.length === 0) list.innerHTML = '<div style="color:#888; padding:20px;">æš‚æ— è®°å½•</div>';
        
        saves.forEach(s => {
            const d = document.createElement('div');
            d.className = 'slot-item';
            d.innerHTML = `
                <div class="slot-info" onclick="Game.start(${s.level}, ${s.id})">
                    <div style="font-weight:bold; color:var(--neon-gold)">${CFG.Levels[s.level].name}</div>
                    <div style="font-size:0.8rem; color:#aaa">ä½“å‹: ${Math.floor(s.score)} | ${s.date}</div>
                </div>
                <div class="del-btn" onclick="App.del(${s.id})">DEL</div>
            `;
            list.appendChild(d);
        });
    },

    getStorage() {
        const raw = SafeStorage.getItem(`DSE_${this.user}`);
        return raw ? JSON.parse(raw) : [];
    },

    save(level, score) {
        let saves = this.getStorage();
        const now = new Date().toLocaleDateString();
        
        if(Game.saveId) {
            const idx = saves.findIndex(s => s.id === Game.saveId);
            if(idx > -1) { saves[idx].level = level; saves[idx].score = score; saves[idx].date = now; }
        } else {
            Game.saveId = Date.now();
            if(saves.length >= CFG.MaxSaves) saves.shift(); // è¶…è¿‡4ä¸ªé¡¶æ‰æœ€æ—©çš„
            saves.push({ id: Game.saveId, level: level, score: score, date: now });
        }
        SafeStorage.setItem(`DSE_${this.user}`, JSON.stringify(saves));
    },

    del(id) {
        if(!confirm('åˆ é™¤æ­¤å­˜æ¡£?')) return;
        let saves = this.getStorage();
        saves = saves.filter(s => s.id !== id);
        SafeStorage.setItem(`DSE_${this.user}`, JSON.stringify(saves));
        this.loadSaves();
    },

    newGame() { Game.start(0, null); },
    logout() { this.user = null; UI.showPanel('p-login'); },
    nextLevel() { 
        this.save(Game.levelIdx+1, Game.player.r);
        Game.start(Game.levelIdx+1, Game.saveId); 
    },
    saveQuit() { 
        this.save(Math.min(Game.levelIdx+1, 1), Game.player.r);
        this.loadSaves();
    },
    toSaves() { this.loadSaves(); }
};

// å¯åŠ¨
Game.init();
</script>
</body>
</html>
