<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ·±æµ·éœ¸ä¸»ï¼šè¿›åŒ– (å­˜æ¡£ç‰ˆ)</title>
    <style>
        :root {
            --primary: #00f2fe;
            --accent: #ffd700;
            --danger: #ff4757;
            --dark-bg: #0a192f;
            --glass: rgba(16, 33, 60, 0.9);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Segoe UI', sans-serif; user-select: none; }
        body { background: #000; overflow: hidden; color: white; height: 100vh; display: flex; justify-content: center; align-items: center; }

        /* èƒŒæ™¯ç”»å¸ƒ */
        #bgCanvas { position: fixed; top: 0; left: 0; z-index: -1; }
        
        /* æ¸¸æˆç”»å¸ƒ */
        #gameCanvas { display: block; width: 100%; height: 100%; }

        /* é€šç”¨UIé¢æ¿ */
        .panel {
            position: absolute;
            background: var(--glass);
            border: 1px solid rgba(255,255,255,0.15);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 40px;
            text-align: center;
            box-shadow: 0 0 30px rgba(0,0,0,0.8);
            max-width: 500px;
            width: 90%;
            display: none; /* é»˜è®¤éšè— */
            animation: fadeIn 0.4s ease;
        }

        @keyframes fadeIn { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }

        h1, h2 { 
            background: linear-gradient(to right, var(--primary), var(--accent));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 20px;
            text-shadow: 0 0 15px rgba(0, 242, 254, 0.3);
        }

        input {
            width: 100%;
            padding: 15px;
            margin: 10px 0 20px;
            border-radius: 8px;
            border: 1px solid #333;
            background: rgba(0,0,0,0.5);
            color: #fff;
            font-size: 1.1rem;
            text-align: center;
            text-transform: uppercase;
        }

        .btn {
            background: linear-gradient(135deg, #00c6ff, #0072ff);
            border: none;
            color: white;
            padding: 12px 30px;
            border-radius: 50px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            margin: 10px;
            transition: 0.2s;
            box-shadow: 0 4px 15px rgba(0, 114, 255, 0.4);
        }

        .btn:hover { transform: scale(1.05); filter: brightness(1.2); }
        .btn.secondary { background: linear-gradient(135deg, #4b6cb7, #182848); }
        .btn.danger { background: linear-gradient(135deg, #ff416c, #ff4b2b); }

        /* å­˜æ¡£æ§½ä½æ ·å¼ */
        .slot-container { display: flex; flex-direction: column; gap: 15px; max-height: 300px; overflow-y: auto; margin-bottom: 20px; }
        .save-slot {
            background: rgba(255,255,255,0.05);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(255,255,255,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            transition: 0.2s;
        }
        .save-slot:hover { background: rgba(255,255,255,0.1); border-color: var(--primary); }
        .save-info { text-align: left; }
        .save-meta { font-size: 0.8rem; color: #888; margin-top: 5px; }
        .slot-actions { display: flex; gap: 10px; }
        .delete-btn { color: var(--danger); background: none; border: none; font-size: 1.2rem; cursor: pointer; padding: 5px; }

        /* æ¸¸æˆHUD */
        .hud {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
            display: none; /* æ¸¸æˆå¼€å§‹åæ˜¾ç¤º */
        }
        .hud-stats { position: absolute; top: 20px; left: 20px; background: rgba(0,0,0,0.6); padding: 15px; border-radius: 10px; border-left: 3px solid var(--primary); }
        .hud-skill-bar { 
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); 
            display: flex; gap: 20px; pointer-events: auto; 
        }
        .skill-box {
            width: 60px; height: 60px; background: rgba(0,0,0,0.7); border: 2px solid #555; border-radius: 12px;
            display: flex; flex-direction: column; justify-content: center; align-items: center; position: relative; overflow: hidden;
        }
        .skill-box.active { border-color: var(--accent); box-shadow: 0 0 15px var(--accent); }
        .skill-key { position: absolute; bottom: 2px; right: 5px; font-size: 0.7rem; color: #aaa; }
        .cd-mask { position: absolute; bottom: 0; left: 0; width: 100%; background: rgba(0,0,0,0.8); height: 0%; transition: height 0.1s linear; }

        /* å…³å¡é€šçŸ¥ç‰¹æ•ˆ */
        .level-title {
            position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%);
            font-size: 4rem; font-weight: bold; opacity: 0; pointer-events: none;
            text-shadow: 0 0 30px var(--primary);
            transition: opacity 1s;
        }
    </style>
</head>
<body>

    <canvas id="bgCanvas"></canvas>
    
    <div id="gameContainer" style="width:100%; height:100%; position: relative;">
        <canvas id="gameCanvas"></canvas>

        <div id="loginPanel" class="panel" style="display: block;">
            <h1>æ·±æµ·éœ¸ä¸»</h1>
            <p style="margin-bottom: 20px; color: #aaa;">è¯·è¾“å…¥æ‚¨çš„ä»£å· (æ‹¼éŸ³é¦–å­—æ¯)</p>
            <input type="text" id="usernameInput" placeholder="ä¾‹å¦‚: ZHANGSAN" maxlength="8">
            <button class="btn" onclick="GameApp.login()">è¿›å…¥ç³»ç»Ÿ</button>
            <p id="loginError" style="color: var(--danger); display: none; margin-top: 10px;">è¯·è¾“å…¥æœ‰æ•ˆçš„ä»£å·</p>
        </div>

        <div id="menuPanel" class="panel">
            <h2 id="welcomeText">æ¬¢è¿å›æ¥</h2>
            <div class="slot-container" id="slotList">
                </div>
            <button class="btn" onclick="GameApp.startNewGame()">+ å¼€å§‹æ–°å¾ç¨‹</button>
            <button class="btn secondary" onclick="GameApp.logout()">é€€å‡ºç™»å½•</button>
        </div>

        <div id="levelCompletePanel" class="panel">
            <h2 style="color: var(--accent);">éœ¸ä¸»é™ä¸´ï¼</h2>
            <p>ä½ å·²ç»Ÿå¾¡äº†è¿™ç‰‡æµ·åŸŸã€‚</p>
            <p style="margin: 20px 0;">å½“å‰å…³å¡: <span id="finishLevelText">1</span></p>
            <p style="color: #aaa; font-size: 0.9rem; margin-bottom: 30px;">å‰æ–¹æ˜¯æœªçŸ¥çš„æ·±æµ·ç¦åŒºï¼Œå±é™©ç³»æ•°æé«˜...</p>
            
            <button class="btn" onclick="GameApp.nextLevel()">ç»§ç»­æŒ‘æˆ˜ (è¿›å…¥æ·±æµ·)</button>
            <button class="btn secondary" onclick="GameApp.saveAndQuit()">å­˜æ¡£å¹¶ä¼‘æ¯</button>
        </div>

        <div id="gameOverPanel" class="panel">
            <h2 style="color: var(--danger);">æ•é£Ÿè€…å˜æˆäº†çŒç‰©</h2>
            <p>ä¸è¦ç°å¿ƒï¼Œæ·±æµ·éœ€è¦è€å¿ƒã€‚</p>
            <button class="btn" onclick="GameApp.reloadLevel()">é‡æ–°æŒ‘æˆ˜æœ¬å…³</button>
            <button class="btn secondary" onclick="GameApp.returnToMenu()">è¿”å›ä¸»èœå•</button>
        </div>

        <div id="hud" class="hud">
            <div class="hud-stats">
                <div>å…³å¡: <span id="hudLevel" style="color: var(--accent); font-weight:bold;">1</span></div>
                <div>ä½“å‹: <span id="hudSize">0</span> / <span id="hudTarget">0</span> cm</div>
                <div>ç”Ÿå‘½: <span id="hudLives" style="color: var(--danger);">â¤â¤â¤</span></div>
            </div>
            <div class="level-title" id="levelAnnounce">LEVEL 1</div>
            
            <div class="hud-skill-bar">
                <div class="skill-box" id="skillSpace">
                    <span>âš¡</span><span class="skill-key">SPACE</span>
                    <div class="cd-mask" id="cdSpace"></div>
                </div>
                <div class="skill-box" id="skillE" style="display:none;">
                    <span>ğŸ”Š</span><span class="skill-key">E</span>
                    <div class="cd-mask" id="cdE"></div>
                </div>
            </div>
        </div>
    </div>

<script>
/**
 * æ¸¸æˆé…ç½®ä¸æ•°æ®ç»“æ„
 */
const CONFIG = {
    levels: [
        {   // Level 1
            id: 1,
            name: "æµ…æ»©ä¹å›­",
            bgType: "ocean",
            targetSize: 50,
            startSize: 15,
            enemyTypes: ['basic', 'basic', 'fast'],
            darkness: 0,
            unlocks: ['dash']
        },
        {   // Level 2
            id: 2,
            name: "æ·±æµ·ç¦åŒº",
            bgType: "deep",
            targetSize: 150,
            startSize: 40, // ç¬¬äºŒå…³åˆå§‹ä½“å‹è¾ƒå¤§
            enemyTypes: ['angler', 'shark', 'whale'],
            darkness: 0.85, // è§†é‡é™åˆ¶
            unlocks: ['dash', 'sonic']
        }
    ],
    skills: {
        dash: { duration: 300, cd: 3000, speedMult: 3 },
        sonic: { duration: 1000, cd: 8000, radius: 250 } // å£°çº³çœ©æ™•
    }
};

/* ================== 1. å­˜å‚¨ä¸è´¦æˆ·ç³»ç»Ÿ ================== */
const StorageSystem = {
    currentUser: null,
    
    // è·å–ç”¨æˆ·æ•°æ®
    getData(username) {
        const raw = localStorage.getItem(`sea_game_${username}`);
        return raw ? JSON.parse(raw) : { saves: [] };
    },

    // ä¿å­˜ç”¨æˆ·æ•°æ®
    saveData(username, data) {
        localStorage.setItem(`sea_game_${username}`, JSON.stringify(data));
    },

    // æ·»åŠ æ–°å­˜æ¡£
    addSave(levelIdx, score, date) {
        let data = this.getData(this.currentUser);
        // é™åˆ¶æœ€å¤š4ä¸ªå­˜æ¡£
        if (data.saves.length >= 4) {
            alert("å­˜æ¡£å·²æ»¡ï¼Œè¯·å…ˆåˆ é™¤æ—§å­˜æ¡£ï¼");
            return false;
        }
        data.saves.push({
            id: Date.now(),
            level: levelIdx,
            score: score,
            date: date
        });
        this.saveData(this.currentUser, data);
        return true;
    },

    // æ›´æ–°ç°æœ‰å­˜æ¡£ï¼ˆå¦‚æœæ˜¯åœ¨ç©æŸä¸ªå­˜æ¡£ï¼‰
    updateSave(saveId, levelIdx, score) {
        let data = this.getData(this.currentUser);
        const idx = data.saves.findIndex(s => s.id === saveId);
        if (idx !== -1) {
            data.saves[idx].level = levelIdx;
            data.saves[idx].score = score;
            data.saves[idx].date = new Date().toLocaleString();
            this.saveData(this.currentUser, data);
        } else {
            // å¦‚æœæ˜¯æ–°æ¸¸æˆï¼Œæ²¡IDï¼Œå°±åˆ›å»ºæ–°çš„
            this.addSave(levelIdx, score, new Date().toLocaleString());
        }
    },

    deleteSave(saveId) {
        let data = this.getData(this.currentUser);
        data.saves = data.saves.filter(s => s.id !== saveId);
        this.saveData(this.currentUser, data);
    }
};

/* ================== 2. æ¸¸æˆå¼•æ“é€»è¾‘ ================== */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const bgCanvas = document.getElementById('bgCanvas');
const bgCtx = bgCanvas.getContext('2d');

let Game = {
    state: 'MENU', // MENU, PLAYING, PAUSED
    width: 0, height: 0,
    currentLevelIdx: 0,
    currentSaveId: null, // å½“å‰æ­£åœ¨ç©çš„å­˜æ¡£IDï¼Œå¦‚æœæ˜¯æ–°æ¸¸æˆåˆ™ä¸ºnull
    loopId: null,
    
    player: {
        x: 0, y: 0, r: 0, vx: 0, vy: 0, 
        angle: 0, lives: 3, score: 0,
        skills: { dash: {cd:0, active:false}, sonic: {cd:0, active:false} }
    },
    enemies: [],
    particles: [],

    init() {
        this.resize();
        window.addEventListener('resize', () => this.resize());
        this.bindInput();
    },

    resize() {
        this.width = window.innerWidth;
        this.height = window.innerHeight;
        canvas.width = this.width; canvas.height = this.height;
        bgCanvas.width = this.width; bgCanvas.height = this.height;
        this.drawBackground();
    },

    drawBackground() {
        const level = CONFIG.levels[this.currentLevelIdx] || CONFIG.levels[0];
        const grad = bgCtx.createLinearGradient(0, 0, 0, this.height);
        
        if (level.bgType === 'deep') {
            grad.addColorStop(0, '#000000');
            grad.addColorStop(1, '#0a192f'); // æ·±è“é»‘
        } else {
            grad.addColorStop(0, '#006994');
            grad.addColorStop(1, '#003366');
        }
        
        bgCtx.fillStyle = grad;
        bgCtx.fillRect(0, 0, this.width, this.height);
        
        // ç»˜åˆ¶ä¸€äº›èƒŒæ™¯æµ·è‰æˆ–æ°”æ³¡
        bgCtx.fillStyle = 'rgba(255,255,255,0.05)';
        for(let i=0; i<50; i++) {
            bgCtx.beginPath();
            bgCtx.arc(Math.random()*this.width, Math.random()*this.height, Math.random()*3, 0, Math.PI*2);
            bgCtx.fill();
        }
    },

    startLevel(levelIdx, saveId = null) {
        this.currentLevelIdx = levelIdx;
        this.currentSaveId = saveId;
        const levelCfg = CONFIG.levels[levelIdx];

        // åˆå§‹åŒ–ç©å®¶
        this.player.x = this.width / 2;
        this.player.y = this.height / 2;
        this.player.r = levelCfg.startSize;
        this.player.vx = 0; this.player.vy = 0;
        this.player.lives = 3;
        // å¦‚æœæ˜¯ç»§ç»­æ¸¸æˆï¼Œåˆ†æ•°å¯èƒ½éœ€è¦è¯»å–ï¼ˆè¿™é‡Œç®€åŒ–ä¸ºå…³å¡é‡ç½®åˆ†æ•°ç´¯è®¡ï¼‰
        
        this.enemies = [];
        this.particles = [];
        this.state = 'PLAYING';
        
        // UI æ›´æ–°
        document.getElementById('hudLevel').innerText = levelCfg.name;
        document.getElementById('hudTarget').innerText = levelCfg.targetSize;
        
        // æŠ€èƒ½å›¾æ ‡æ˜¾ç¤º
        document.getElementById('skillE').style.display = levelCfg.unlocks.includes('sonic') ? 'flex' : 'none';

        // å…³å¡å…¬å‘ŠåŠ¨ç”»
        const title = document.getElementById('levelAnnounce');
        title.innerText = levelCfg.name;
        title.style.opacity = 1;
        title.style.transform = "translate(-50%, -50%) scale(1.2)";
        setTimeout(() => { 
            title.style.opacity = 0; 
            title.style.transform = "translate(-50%, -50%) scale(1)";
        }, 2000);

        this.drawBackground(); // é‡ç»˜èƒŒæ™¯
        this.loop();
    },

    loop() {
        if (this.state !== 'PLAYING') return;

        ctx.clearRect(0, 0, this.width, this.height);
        
        this.update();
        this.draw();

        this.loopId = requestAnimationFrame(() => this.loop());
    },

    update() {
        const p = this.player;
        const levelCfg = CONFIG.levels[this.currentLevelIdx];

        // 1. ç©å®¶ç§»åŠ¨ (ç‰©ç†æƒ¯æ€§)
        let speed = 4;
        if (p.skills.dash.active) speed *= CONFIG.skills.dash.speedMult;
        // æ·±æµ·é˜»åŠ›å¤§
        if (levelCfg.bgType === 'deep') speed *= 0.8;

        if (Input.keys['ArrowUp']) p.vy -= 0.5;
        if (Input.keys['ArrowDown']) p.vy += 0.5;
        if (Input.keys['ArrowLeft']) p.vx -= 0.5;
        if (Input.keys['ArrowRight']) p.vx += 0.5;

        p.vx *= 0.95; p.vy *= 0.95; // æ‘©æ“¦
        // é™é€Ÿ
        const v = Math.sqrt(p.vx*p.vx + p.vy*p.vy);
        if (v > speed) { p.vx = (p.vx/v)*speed; p.vy = (p.vy/v)*speed; }

        p.x += p.vx; p.y += p.vy;
        
        // è¾¹ç•Œ
        if(p.x < p.r) p.x = p.r; if(p.x > this.width - p.r) p.x = this.width - p.r;
        if(p.y < p.r) p.y = p.r; if(p.y > this.height - p.r) p.y = this.height - p.r;

        // è§’åº¦
        if (v > 0.1) p.angle = Math.atan2(p.vy, p.vx);

        // 2. æ•Œäººç”Ÿæˆ
        if (this.enemies.length < 15 + this.currentLevelIdx * 5 && Math.random() < 0.03) {
            this.spawnEnemy(levelCfg);
        }

        // 3. æ•Œäººé€»è¾‘ä¸ç¢°æ’
        this.enemies.forEach((e, i) => {
            // ç‰¹æ®ŠAI: é²¨é±¼è¿½è¸ª
            if (e.type === 'shark' && !p.skills.sonic.active) {
                const dx = p.x - e.x; const dy = p.y - e.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < 400) { // è§†é‡
                    e.vx += (dx/dist) * 0.1;
                    e.vy += (dy/dist) * 0.1;
                }
            }
            // çœ©æ™•é€»è¾‘
            if (e.stunned > 0) {
                e.stunned--;
                e.vx *= 0.5; e.vy *= 0.5; // å‡é€Ÿ
            } else {
                e.x += e.vx; e.y += e.vy;
            }

            // ç§»é™¤å‡ºç•Œ
            if (e.x < -200 || e.x > this.width + 200) { this.enemies.splice(i, 1); return; }

            // ç¢°æ’
            const dx = p.x - e.x; const dy = p.y - e.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            
            if (dist < p.r + e.r) {
                if (p.r > e.r) {
                    // åƒæ‰
                    p.r += e.r * 0.05;
                    p.score += Math.floor(e.r);
                    this.enemies.splice(i, 1);
                    this.createParticles(e.x, e.y, e.color, 5);
                    // æ£€æŸ¥è¿‡å…³
                    if (p.r >= levelCfg.targetSize) {
                        GameApp.levelComplete();
                    }
                } else {
                    // å—ä¼¤
                    if (!p.invincible) {
                        p.lives--;
                        p.invincible = true;
                        this.createParticles(p.x, p.y, '#ff0000', 10);
                        setTimeout(() => p.invincible = false, 1500);
                        if (p.lives <= 0) GameApp.gameOver();
                    }
                }
            }
        });

        // 4. æŠ€èƒ½CD
        for(let key in p.skills) {
            if(p.skills[key].cd > 0) p.skills[key].cd -= 16; // approx 60fps
        }

        // UI Update
        document.getElementById('hudSize').innerText = Math.floor(p.r);
        document.getElementById('hudLives').innerText = "â¤".repeat(p.lives);
        this.updateSkillUI('Space', 'dash');
        this.updateSkillUI('E', 'sonic');
    },

    spawnEnemy(levelCfg) {
        const type = levelCfg.enemyTypes[Math.floor(Math.random() * levelCfg.enemyTypes.length)];
        let e = { x: 0, y: Math.random()*this.height, vx: 0, vy: 0, r: 10, color: '#fff', type: type, stunned: 0 };
        
        // æ ¹æ®ç±»å‹é…ç½®å±æ€§
        if (type === 'basic') { e.r = 5 + Math.random()*15; e.color = '#ff9f43'; e.vx = 2; }
        else if (type === 'fast') { e.r = 10 + Math.random()*10; e.color = '#00d2d3'; e.vx = 4; }
        else if (type === 'angler') { e.r = 20 + Math.random()*20; e.color = '#5f27cd'; e.vx = 1.5; } // ç¯ç¬¼é±¼
        else if (type === 'shark') { e.r = 35 + Math.random()*30; e.color = '#576574'; e.vx = 3; } // é²¨é±¼
        else if (type === 'whale') { e.r = 80 + Math.random()*40; e.color = '#222f3e'; e.vx = 0.5; } // é²¸é±¼

        // å·¦å³ç”Ÿæˆ
        if (Math.random() > 0.5) { e.x = -50; } else { e.x = this.width+50; e.vx *= -1; }
        e.angle = Math.atan2(e.vy, e.vx);
        
        this.enemies.push(e);
    },

    draw() {
        const p = this.player;
        const levelCfg = CONFIG.levels[this.currentLevelIdx];

        // 1. è§†é‡é™åˆ¶ (æ·±æµ·æ¨¡å¼)
        if (levelCfg.darkness > 0) {
            // åˆ›å»ºä¸€ä¸ªé®ç½©ï¼Œåªæœ‰ç©å®¶å‘¨å›´æ˜¯äº®çš„
            ctx.fillStyle = `rgba(0,0,0,${levelCfg.darkness})`;
            ctx.fillRect(0, 0, this.width, this.height);
            
            // æŒ–æ´ (ä½¿ç”¨ composite operation)
            ctx.globalCompositeOperation = 'destination-out';
            
            // ç©å®¶å…‰ç¯
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.r * 4 + 100, 0, Math.PI*2);
            ctx.fillStyle = 'rgba(0,0,0,1)';
            ctx.fill();

            // ç¯ç¬¼é±¼å…‰ç¯
            this.enemies.forEach(e => {
                if (e.type === 'angler') {
                    ctx.beginPath();
                    ctx.arc(e.x + Math.cos(e.angle)*e.r, e.y + Math.sin(e.angle)*e.r, e.r * 2, 0, Math.PI*2);
                    ctx.fill();
                }
            });

            ctx.globalCompositeOperation = 'source-over';
        }

        // 2. ç»˜åˆ¶ç©å®¶
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate(p.angle);
        
        if (p.invincible && Math.floor(Date.now()/100)%2===0) ctx.globalAlpha = 0.5;

        // èº«ä½“
        ctx.beginPath();
        ctx.ellipse(0, 0, p.r, p.r*0.6, 0, 0, Math.PI*2);
        ctx.fillStyle = '#00f2fe';
        ctx.fill();
        // å°¾å·´
        ctx.beginPath();
        ctx.moveTo(-p.r*0.8, 0);
        ctx.lineTo(-p.r*1.6, -p.r*0.6);
        ctx.lineTo(-p.r*1.6, p.r*0.6);
        ctx.fill();

        // æŠ€èƒ½ç‰¹æ•ˆï¼šå£°çº³
        if (p.skills.sonic.active) {
            ctx.beginPath();
            ctx.arc(0, 0, p.r + 50 + Math.random()*20, 0, Math.PI*2);
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 3;
            ctx.stroke();
        }

        ctx.restore();

        // 3. ç»˜åˆ¶æ•Œäºº
        this.enemies.forEach(e => {
            ctx.save();
            ctx.translate(e.x, e.y);
            // é²¨é±¼é¢å‘ç§»åŠ¨æ–¹å‘ï¼Œå…¶ä»–å¯èƒ½æ ¹æ®vx
            let angle = Math.atan2(e.vy, e.vx);
            if(e.type === 'shark') angle = Math.atan2(e.vy, e.vx);
            ctx.rotate(angle);

            if (e.stunned > 0) ctx.globalAlpha = 0.5; // çœ©æ™•æ•ˆæœ

            // ç»˜åˆ¶é€»è¾‘
            ctx.fillStyle = e.color;
            ctx.beginPath();
            
            if (e.type === 'whale') {
                ctx.ellipse(0, 0, e.r, e.r*0.5, 0, 0, Math.PI*2); // èƒ–ä¸€ç‚¹
            } else if (e.type === 'shark') {
                 // é²¨é±¼å°–å¤´
                ctx.moveTo(e.r, 0);
                ctx.lineTo(-e.r, -e.r*0.5);
                ctx.lineTo(-e.r, e.r*0.5);
                ctx.fill();
                // èƒŒé³
                ctx.beginPath(); ctx.moveTo(0, -e.r*0.3); ctx.lineTo(-e.r*0.5, -e.r); ctx.lineTo(e.r*0.2, -e.r*0.3); ctx.fill();
            } else if (e.type === 'angler') {
                // åœ†ä½“
                ctx.arc(0, 0, e.r*0.8, 0, Math.PI*2);
                ctx.fill();
                // ç¯
                ctx.beginPath(); ctx.moveTo(0, -e.r*0.6); ctx.lineTo(e.r, -e.r*1.2); ctx.stroke();
                ctx.beginPath(); ctx.arc(e.r, -e.r*1.2, 3, 0, Math.PI*2); ctx.fillStyle='#ffff00'; ctx.fill();
            } else {
                // æ™®é€šé±¼
                ctx.ellipse(0, 0, e.r, e.r*0.6, 0, 0, Math.PI*2);
                ctx.fill();
                ctx.beginPath(); ctx.moveTo(-e.r*0.5, 0); ctx.lineTo(-e.r*1.5, -e.r*0.5); ctx.lineTo(-e.r*1.5, e.r*0.5); ctx.fill();
            }
            
            ctx.fillStyle = e.color; // Reset for specific fills above if needed
            if(e.type !== 'shark') ctx.fill();

            ctx.restore();
        });

        // 4. ç²’å­ç‰¹æ•ˆ
        this.particles.forEach((p, i) => {
            p.x += p.vx; p.y += p.vy; p.life -= 0.05;
            ctx.globalAlpha = p.life;
            ctx.fillStyle = p.color;
            ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI*2); ctx.fill();
            if(p.life <= 0) this.particles.splice(i, 1);
        });
        ctx.globalAlpha = 1;
    },

    createParticles(x, y, color, count) {
        for(let i=0; i<count; i++) {
            this.particles.push({
                x:x, y:y, vx:(Math.random()-0.5)*5, vy:(Math.random()-0.5)*5, 
                r:Math.random()*3, color:color, life:1
            });
        }
    },

    updateSkillUI(keyName, skillId) {
        const skill = this.player.skills[skillId];
        const cfg = CONFIG.skills[skillId];
        const mask = document.getElementById('cd'+keyName);
        const box = document.getElementById('skill'+keyName);
        
        if (skill.cd > 0) {
            mask.style.height = (skill.cd / cfg.cd * 100) + '%';
            box.classList.remove('active');
        } else {
            mask.style.height = '0%';
            if (skill.active) box.classList.add('active');
            else box.classList.remove('active');
        }
    },

    // æŠ€èƒ½é‡Šæ”¾
    activateSkill(skillName) {
        const skill = this.player.skills[skillName];
        const cfg = CONFIG.skills[skillName];
        
        if (skill.cd <= 0 && !skill.active) {
            skill.active = true;
            skill.cd = cfg.cd;

            if (skillName === 'sonic') {
                // å£°çº³ï¼šçœ©æ™•èŒƒå›´å†…æ•Œäºº
                this.enemies.forEach(e => {
                    const d = Math.sqrt((e.x-this.player.x)**2 + (e.y-this.player.y)**2);
                    if (d < cfg.radius) e.stunned = 120; // 2ç§’ (60fps)
                });
            }

            setTimeout(() => { skill.active = false; }, cfg.duration);
        }
    },

    bindInput() {
        window.addEventListener('keydown', e => {
            Input.keys[e.code] = true;
            if (this.state === 'PLAYING') {
                if (e.code === 'Space') this.activateSkill('dash');
                if (e.code === 'KeyE' && CONFIG.levels[this.currentLevelIdx].unlocks.includes('sonic')) this.activateSkill('sonic');
            }
        });
        window.addEventListener('keyup', e => Input.keys[e.code] = false);
    }
};

const Input = { keys: {} };

/* ================== 3. UI äº¤äº’æ§åˆ¶ ================== */
const GameApp = {
    login() {
        const input = document.getElementById('usernameInput');
        const username = input.value.trim().toUpperCase();
        const regex = /^[A-Z]+$/;

        if (username && regex.test(username)) {
            StorageSystem.currentUser = username;
            document.getElementById('loginPanel').style.display = 'none';
            this.showMenu();
        } else {
            document.getElementById('loginError').style.display = 'block';
        }
    },

    logout() {
        StorageSystem.currentUser = null;
        document.getElementById('menuPanel').style.display = 'none';
        document.getElementById('loginPanel').style.display = 'block';
    },

    showMenu() {
        const panel = document.getElementById('menuPanel');
        document.getElementById('welcomeText').innerText = `æ¬¢è¿å›æ¥, ${StorageSystem.currentUser}`;
        panel.style.display = 'block';
        this.renderSlots();
        
        // éšè—å…¶ä»–
        document.getElementById('hud').style.display = 'none';
        document.getElementById('gameCanvas').style.opacity = 0.3;
        Game.state = 'MENU';
    },

    renderSlots() {
        const container = document.getElementById('slotList');
        container.innerHTML = '';
        const data = StorageSystem.getData(StorageSystem.currentUser);

        if (data.saves.length === 0) {
            container.innerHTML = '<div style="color:#aaa; padding:20px;">æš‚æ— å­˜æ¡£</div>';
            return;
        }

        data.saves.forEach(save => {
            const levelName = CONFIG.levels[save.level] ? CONFIG.levels[save.level].name : "æœªçŸ¥æµ·åŸŸ";
            const div = document.createElement('div');
            div.className = 'save-slot';
            div.innerHTML = `
                <div class="save-info" onclick="GameApp.loadGame(${save.id}, ${save.level})">
                    <div style="color:var(--primary); font-weight:bold;">${levelName}</div>
                    <div class="save-meta">åˆ†æ•°: ${save.score} | æ—¶é—´: ${save.date}</div>
                </div>
                <div class="slot-actions">
                    <button class="delete-btn" onclick="GameApp.deleteSave(${save.id})">Ã—</button>
                </div>
            `;
            container.appendChild(div);
        });
    },

    startNewGame() {
        document.getElementById('menuPanel').style.display = 'none';
        this.startGameUI();
        Game.startLevel(0, null); // Level 1, no save ID yet
    },

    loadGame(saveId, levelIdx) {
        document.getElementById('menuPanel').style.display = 'none';
        this.startGameUI();
        Game.startLevel(levelIdx, saveId);
    },

    deleteSave(id) {
        if(confirm("ç¡®å®šè¦åˆ é™¤è¿™ä¸ªå­˜æ¡£å—ï¼Ÿ")) {
            StorageSystem.deleteSave(id);
            this.renderSlots();
        }
    },

    startGameUI() {
        document.getElementById('gameCanvas').style.opacity = 1;
        document.getElementById('hud').style.display = 'block';
        document.getElementById('levelCompletePanel').style.display = 'none';
        document.getElementById('gameOverPanel').style.display = 'none';
    },

    levelComplete() {
        Game.state = 'PAUSED';
        const panel = document.getElementById('levelCompletePanel');
        document.getElementById('finishLevelText').innerText = CONFIG.levels[Game.currentLevelIdx].name;
        
        // æ£€æŸ¥æ˜¯å¦è¿˜æœ‰ä¸‹ä¸€å…³
        const nextBtn = panel.querySelector('.btn');
        if (Game.currentLevelIdx + 1 >= CONFIG.levels.length) {
            nextBtn.innerText = "é€šå…³ï¼å›åˆ°ä¸»èœå•";
            nextBtn.onclick = () => this.returnToMenu();
        } else {
            nextBtn.innerText = "ç»§ç»­æŒ‘æˆ˜ (è¿›å…¥ä¸‹ä¸€å…³)";
            nextBtn.onclick = () => this.nextLevel();
        }
        
        panel.style.display = 'block';
    },

    nextLevel() {
        const nextIdx = Game.currentLevelIdx + 1;
        // å¦‚æœæœ‰å­˜æ¡£IDï¼Œè‡ªåŠ¨ä¿å­˜è¿›åº¦
        if (Game.currentSaveId) {
            StorageSystem.updateSave(Game.currentSaveId, nextIdx, Game.player.score);
        }
        this.startGameUI();
        Game.startLevel(nextIdx, Game.currentSaveId);
    },

    saveAndQuit() {
        // ä¿å­˜å½“å‰è¿›åº¦çš„ä¸‹ä¸€å…³
        const nextIdx = Game.currentLevelIdx + 1 < CONFIG.levels.length ? Game.currentLevelIdx + 1 : Game.currentLevelIdx;
        if (Game.currentSaveId) {
            StorageSystem.updateSave(Game.currentSaveId, nextIdx, Game.player.score);
        } else {
            StorageSystem.addSave(nextIdx, Game.player.score, new Date().toLocaleString());
        }
        this.showMenu();
        document.getElementById('levelCompletePanel').style.display = 'none';
    },

    gameOver() {
        Game.state = 'GAME_OVER';
        document.getElementById('gameOverPanel').style.display = 'block';
    },

    reloadLevel() {
        this.startGameUI();
        Game.startLevel(Game.currentLevelIdx, Game.currentSaveId);
    },

    returnToMenu() {
        this.showMenu();
        document.getElementById('gameOverPanel').style.display = 'none';
        document.getElementById('levelCompletePanel').style.display = 'none';
    }
};

// å¯åŠ¨
Game.init();

</script>
</body>
</html>
