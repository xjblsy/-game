<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Deep Sea Evolution: Genesis</title>
    <style>
        :root {
            --primary: #00f2fe;
            --secondary: #4facfe;
            --accent: #ffd700;
            --danger: #ff4757;
            --dark-overlay: rgba(5, 10, 20, 0.95);
        }

        body {
            margin: 0; padding: 0;
            background-color: #000510;
            overflow: hidden;
            font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
            color: white;
            user-select: none;
        }

        /* æ¸¸æˆç”»å¸ƒå±‚ */
        canvas {
            display: block;
            position: absolute;
            top: 0; left: 0;
            z-index: 1;
        }

        /* UI äº¤äº’å±‚ */
        #ui-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 10;
            pointer-events: none; /* è®©é¼ æ ‡äº‹ä»¶ç©¿é€åˆ°æ¸¸æˆ */
        }

        /* é€šç”¨é¢æ¿ç»„ä»¶ */
        .panel {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: var(--dark-overlay);
            border: 1px solid rgba(255, 255, 255, 0.15);
            box-shadow: 0 0 40px rgba(0, 242, 254, 0.1);
            backdrop-filter: blur(12px);
            padding: 40px;
            border-radius: 16px;
            text-align: center;
            min-width: 400px;
            pointer-events: auto; /* æ¢å¤ç‚¹å‡» */
            display: none;
            animation: fadeIn 0.4s ease;
        }
        .panel.active { display: block; }

        @keyframes fadeIn { from { opacity: 0; transform: translate(-50%, -40%); } to { opacity: 1; transform: translate(-50%, -50%); } }

        h1 { margin-bottom: 20px; font-weight: 800; letter-spacing: 2px; background: linear-gradient(to right, #fff, var(--primary)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        
        input {
            width: 100%; padding: 14px; margin-bottom: 20px;
            background: rgba(0,0,0,0.5); border: 1px solid #333;
            color: white; font-size: 1.1rem; text-align: center;
            border-radius: 8px; outline: none; transition: 0.3s;
        }
        input:focus { border-color: var(--primary); box-shadow: 0 0 15px rgba(0, 242, 254, 0.2); }

        .btn {
            background: linear-gradient(135deg, var(--secondary), var(--primary));
            border: none; padding: 12px 30px; border-radius: 50px;
            color: #000; font-weight: bold; font-size: 1rem;
            cursor: pointer; transition: 0.2s; box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
        .btn:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(0, 242, 254, 0.4); }
        .btn.outline { background: transparent; border: 1px solid rgba(255,255,255,0.3); color: #fff; }
        .btn.outline:hover { background: rgba(255,255,255,0.1); }

        /* å­˜æ¡£åˆ—è¡¨ */
        .slot-list { margin: 20px 0; max-height: 200px; overflow-y: auto; text-align: left; }
        .slot-item {
            padding: 12px; margin-bottom: 8px; border-radius: 8px;
            background: rgba(255,255,255,0.05); cursor: pointer;
            display: flex; justify-content: space-between; align-items: center;
            border: 1px solid transparent; transition: 0.2s;
        }
        .slot-item:hover { border-color: var(--primary); background: rgba(0, 242, 254, 0.05); }
        .del-btn { color: var(--danger); font-size: 1.2rem; padding: 0 10px; }

        /* HUD - æ¸¸æˆå†…ç•Œé¢ */
        #hud { display: none; }
        .hud-stats { position: absolute; top: 20px; left: 20px; display: flex; gap: 15px; }
        .stat-box { 
            background: rgba(0,0,0,0.7); padding: 8px 16px; border-radius: 20px; 
            border: 1px solid rgba(255,255,255,0.1); font-weight: bold; font-size: 0.9rem;
        }

        /* æŠ€èƒ½æ  */
        .skill-bar { 
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 15px; pointer-events: auto;
        }
        .skill-slot {
            width: 64px; height: 64px; background: rgba(10,20,30,0.9);
            border: 2px solid #333; border-radius: 12px;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            position: relative; overflow: hidden; transition: 0.2s;
        }
        .skill-slot.active { border-color: var(--accent); box-shadow: 0 0 15px rgba(255, 215, 0, 0.3); }
        .skill-icon { font-size: 1.5rem; z-index: 2; }
        .skill-key { font-size: 0.7rem; color: #888; margin-top: 2px; z-index: 2; }
        .cd-mask { 
            position: absolute; bottom: 0; left: 0; width: 100%; height: 0%; 
            background: rgba(0,0,0,0.8); z-index: 1; transition: height 0.1s linear; 
        }

        /* æµ®åŠ¨æ–‡å­— */
        .float-text {
            position: absolute; font-weight: 900; font-size: 1.2rem; pointer-events: none;
            text-shadow: 0 2px 5px black; animation: floatUp 0.8s forwards;
        }
        @keyframes floatUp { to { transform: translateY(-40px); opacity: 0; } }

        /* é”™è¯¯æç¤º */
        .error-shake { animation: shake 0.4s ease-in-out; border-color: var(--danger) !important; }
        @keyframes shake { 0%,100%{transform:translateX(0)} 25%{transform:translateX(-5px)} 75%{transform:translateX(5px)} }

        /* å°åœ°å›¾é›·è¾¾ (è£…é¥°æ€§) */
        .minimap {
            position: absolute; top: 20px; right: 20px; width: 100px; height: 100px;
            border-radius: 50%; border: 2px solid rgba(255,255,255,0.2);
            background: rgba(0,0,0,0.5); overflow: hidden; opacity: 0.6;
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div id="p-pass" class="panel active">
            <h1>SYSTEM LOCKED</h1>
            <p>è¾“å…¥æœ€é«˜æƒé™å¯†é’¥å¯åŠ¨ç³»ç»Ÿ</p>
            <input type="password" id="inp-pass" placeholder="Password">
            <button class="btn" onclick="UI.verifyPass()">ACCESS</button>
        </div>

        <div id="p-login" class="panel">
            <h1>IDENTITY</h1>
            <p>è¾“å…¥æ‚¨çš„ä»£å· (æ‹¼éŸ³é¦–å­—æ¯)</p>
            <input type="text" id="inp-user" placeholder="ä¾‹å¦‚: ZHANGSAN" maxlength="12">
            <button class="btn" onclick="UI.login()">CONNECT</button>
        </div>

        <div id="p-saves" class="panel">
            <h1>ARCHIVES</h1>
            <p id="txt-welcome"></p>
            <div class="slot-list" id="slot-list"></div>
            <div style="margin-top: 20px;">
                <button class="btn" onclick="App.newGame()">æ–°å¾ç¨‹</button>
                <button class="btn outline" onclick="App.logout()">é€€å‡º</button>
            </div>
        </div>

        <div id="p-win" class="panel">
            <h1 style="color: var(--accent);">DOMINATED</h1>
            <p>å½“å‰æµ·åŸŸå·²å¾æœ</p>
            <div style="text-align: left; background: rgba(255,255,255,0.05); padding: 15px; border-radius: 8px; margin: 20px 0;">
                <p style="margin:0; font-weight:bold;">ä¸‹ä¸€ç«™ï¼šæ·±æ¸Šç¦åŒº</p>
                <small style="color:#aaa;">ç¯å¢ƒï¼šé«˜å‹ã€æ— å…‰ã€å·¨å‹ç”Ÿç‰©</small>
            </div>
            <button class="btn" onclick="App.nextLevel()">æ½œå…¥æ·±æ¸Š</button>
            <button class="btn outline" onclick="App.saveAndQuit()">å­˜æ¡£ä¼‘æ¯</button>
        </div>

        <div id="p-dead" class="panel">
            <h1 style="color: var(--danger);">CRITICAL FAILURE</h1>
            <p>ç”Ÿå‘½ä¿¡å·ä¸­æ–­...</p>
            <button class="btn" onclick="Game.retry()">é‡ç»„åŸºå› </button>
            <button class="btn outline" onclick="App.loadSaves()">è¿”å›</button>
        </div>

        <div id="hud">
            <div class="hud-stats">
                <div class="stat-box" style="border-color: var(--danger); color: var(--danger);">
                    â¤ <span id="ui-lives">3</span>
                </div>
                <div class="stat-box" style="border-color: var(--primary); color: var(--primary);">
                    ğŸ“ <span id="ui-size">0</span>
                </div>
                <div class="stat-box">
                    âš“ <span id="ui-zone">Zone 1</span>
                </div>
            </div>
            <div class="minimap">
                <div style="position:absolute; top:50%; left:50%; width:4px; height:4px; background:#0f0; border-radius:50%; transform:translate(-50%,-50%);"></div>
            </div>

            <div class="skill-bar">
                <div class="skill-slot" id="s-dash">
                    <div class="skill-icon">âš¡</div><div class="skill-key">SPACE</div>
                    <div class="cd-mask" id="cd-dash"></div>
                </div>
                <div class="skill-slot" id="s-shield">
                    <div class="skill-icon">ğŸ›¡ï¸</div><div class="skill-key">J</div>
                    <div class="cd-mask" id="cd-shield"></div>
                </div>
                <div class="skill-slot" id="s-magnet">
                    <div class="skill-icon">ğŸ§²</div><div class="skill-key">K</div>
                    <div class="cd-mask" id="cd-magnet"></div>
                </div>
                <div class="skill-slot" id="s-sonar" style="display:none;">
                    <div class="skill-icon">ğŸ“¡</div><div class="skill-key">L</div>
                    <div class="cd-mask" id="cd-sonar"></div>
                </div>
            </div>
        </div>
    </div>

<script>
/**
 * Deep Sea Evolution: Ultimate Edition
 * æ ¸å¿ƒæ¶æ„ï¼š
 * 1. SafeStorage: è§£å†³æœ¬åœ°è¿è¡Œæ—¶çš„å­˜å‚¨æŠ¥é”™
 * 2. EntitySystem: åŒ…å«å¤šå…³èŠ‚éª¨éª¼åŠ¨ç”»ç³»ç»Ÿ (Verlet Integrationç®€åŒ–ç‰ˆ)
 * 3. GameLoop: è´Ÿè´£é€»è¾‘ä¸æ¸²æŸ“åˆ†ç¦»
 * 4. Camera: ç©å®¶å±…ä¸­ï¼Œä¸–ç•Œç§»åŠ¨
 */

/* --- 0. åŸºç¡€å·¥å…· --- */
const SafeStorage = {
    _mem: {},
    available: false,
    init() {
        try { localStorage.setItem('test', '1'); localStorage.removeItem('test'); this.available = true; }
        catch(e) { console.log('Storage restricted, using memory.'); }
    },
    get(k) { return this.available ? localStorage.getItem(k) : this._mem[k]; },
    set(k, v) { if(this.available) localStorage.setItem(k, v); else this._mem[k] = v; }
};
SafeStorage.init();

const CFG = {
    PASS: 'xjblsy99',
    WORLD_SIZE: 3000,
    LEVELS: [
        { id:0, name:"é˜³å…‰æµ…æ»©", target:60, startR:15, dark:0, skills:['dash','shield','magnet'], bg:['#006994','#003366'], spawns:['tetra','goldie','ray'] },
        { id:1, name:"æ·±æ¸Šç¦åŒº", target:200, startR:70, dark:0.95, skills:['dash','shield','magnet','sonar'], bg:['#050505','#1a0b2e'], spawns:['goldie','angler','shark','whale'] }
    ],
    FISH: {
        tetra:  { r:[5,12],   spd:3.0, color:'#ff00cc', type:'neon' },
        goldie: { r:[12,25],  spd:2.2, color:'#ff9f43', type:'gold' },
        ray:    { r:[20,35],  spd:2.5, color:'#00d2d3', type:'flat' },
        angler: { r:[35,55],  spd:1.8, color:'#a55eea', type:'angler' },
        shark:  { r:[50,80],  spd:4.0, color:'#7f8fa6', type:'shark', aggro:true },
        whale:  { r:[90,150], spd:1.2, color:'#2f3542', type:'whale' }
    },
    SKILLS: {
        dash: { cd:3000, dur:300, color:'#00f2fe' },
        shield: { cd:12000, dur:3000, color:'#ffd700' },
        magnet: { cd:15000, dur:4000, color:'#bd00ff', r:400 },
        sonar: { cd:20000, dur:100, color:'#fff', r:1200 }
    }
};

/* --- 1. å®ä½“ä¸éª¨éª¼ç³»ç»Ÿ (High Quality Modeling) --- */
class FishEntity {
    constructor(x, y, r, color, type) {
        this.x = x; this.y = y;
        this.vx = 0; this.vy = 0;
        this.r = r;
        this.color = color;
        this.type = type;
        this.angle = 0;
        
        // éª¨éª¼ç³»ç»Ÿ: èº«ä½“èŠ‚ç‚¹
        // æ¯ä¸ªèŠ‚ç‚¹è·Ÿéšå‰ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå½¢æˆè›‡å½¢è¿åŠ¨
        this.bodyParts = [];
        const partCount = type === 'shark' || type === 'whale' ? 8 : 5;
        for(let i=0; i<partCount; i++) {
            this.bodyParts.push({ x: x, y: y, r: r * (1 - i/(partCount+1)) });
        }
    }

    updateBody(speed) {
        // å¤´éƒ¨ä½ç½®å°±æ˜¯ this.x, this.y
        // ç¬¬0ä¸ªèº«ä½“èŠ‚ç‚¹è·Ÿéšå¤´éƒ¨
        this.solveLink(this.bodyParts[0], {x:this.x, y:this.y}, speed);
        // åç»­èŠ‚ç‚¹è·Ÿéšå‰ä¸€ä¸ª
        for(let i=1; i<this.bodyParts.length; i++) {
            this.solveLink(this.bodyParts[i], this.bodyParts[i-1], speed);
        }
    }

    solveLink(current, target, speed) {
        const dx = target.x - current.x;
        const dy = target.y - current.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        const angle = Math.atan2(dy, dx);
        
        // é—´è·ï¼šåŸºäºåŠå¾„çš„ä¸€å®šæ¯”ä¾‹
        const spacing = this.r * 0.4; 
        
        // ç®€å•çš„IKè·Ÿéšé€»è¾‘
        if(dist > spacing) {
            current.x = target.x - Math.cos(angle) * spacing;
            current.y = target.y - Math.sin(angle) * spacing;
        }
    }

    draw(ctx) {
        // 1. ç»˜åˆ¶èº«ä½“è¿æ¥ (å¹³æ»‘æ›²çº¿)
        ctx.fillStyle = this.color;
        
        // å¤´éƒ¨
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r, 0, Math.PI*2);
        ctx.fill();

        // çœ¼ç›
        const eyeOff = this.r*0.4;
        const eyeX = this.x + Math.cos(this.angle + 0.5) * eyeOff;
        const eyeY = this.y + Math.sin(this.angle + 0.5) * eyeOff;
        const eyeX2 = this.x + Math.cos(this.angle - 0.5) * eyeOff;
        const eyeY2 = this.y + Math.sin(this.angle - 0.5) * eyeOff;
        
        ctx.fillStyle = '#fff';
        ctx.beginPath(); ctx.arc(eyeX, eyeY, this.r*0.3, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(eyeX2, eyeY2, this.r*0.3, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#000';
        ctx.beginPath(); ctx.arc(eyeX, eyeY, this.r*0.15, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(eyeX2, eyeY2, this.r*0.15, 0, Math.PI*2); ctx.fill();

        // èº«ä½“èŠ‚ç‚¹
        ctx.fillStyle = this.color;
        this.bodyParts.forEach((p, i) => {
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
            ctx.fill();
            
            // è£…é¥°ï¼šé²¨é±¼èƒŒé³
            if(this.type === 'shark' && i === 1) {
                ctx.save();
                ctx.translate(p.x, p.y);
                ctx.rotate(this.angle);
                ctx.beginPath();
                ctx.moveTo(0,0); ctx.lineTo(-this.r, -this.r*2); ctx.lineTo(this.r, 0);
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.fill();
                ctx.restore();
            }
        });

        // ç¯ç¬¼é±¼çš„ç¯
        if(this.type === 'angler') {
            const lx = this.x + Math.cos(this.angle)*this.r*1.5;
            const ly = this.y + Math.sin(this.angle)*this.r*1.5;
            ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(lx, ly);
            ctx.strokeStyle = '#888'; ctx.lineWidth = 2; ctx.stroke();
            ctx.beginPath(); ctx.arc(lx, ly, 6, 0, Math.PI*2); 
            ctx.fillStyle = '#ff0'; ctx.fill();
            ctx.shadowBlur = 20; ctx.shadowColor = '#ff0'; ctx.fill(); ctx.shadowBlur = 0;
        }
    }
}

/* --- 2. æ¸¸æˆæ ¸å¿ƒ --- */
const Game = {
    canvas: null, ctx: null,
    W: 0, H: 0,
    loopId: null,
    state: 'STOP',
    
    // æ‘„åƒæœº
    cam: { x:0, y:0 },

    player: null,
    enemies: [],
    particles: [],
    keys: {},
    
    levelIdx: 0,
    saveId: null,
    shake: 0,

    init() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.resize();
        
        window.addEventListener('resize', () => this.resize());
        
        // é”®ç›˜ç›‘å¬
        window.addEventListener('keydown', e => {
            this.keys[e.key] = true;
            if(this.state === 'PLAY') {
                if(e.code === 'Space') this.skill('dash');
                if(e.code === 'KeyJ') this.skill('shield');
                if(e.code === 'KeyK') this.skill('magnet');
                if(e.code === 'KeyL') this.skill('sonar');
            }
            if(e.key === 'Enter') UI.handleEnter();
        });
        window.addEventListener('keyup', e => this.keys[e.key] = false);
    },

    resize() {
        this.W = window.innerWidth;
        this.H = window.innerHeight;
        this.canvas.width = this.W;
        this.canvas.height = this.H;
    },

    start(lvlIdx, saveId) {
        if(!this.ctx) return; // é˜²æ­¢è¿‡æ—©è°ƒç”¨
        
        this.levelIdx = lvlIdx;
        this.saveId = saveId;
        const cfg = CFG.LEVELS[lvlIdx];

        // åˆå§‹åŒ–ç©å®¶ (ä½äºä¸–ç•Œä¸­å¿ƒ)
        this.player = new FishEntity(CFG.WORLD_SIZE/2, CFG.WORLD_SIZE/2, cfg.startR, '#00f2fe', 'player');
        this.player.lives = 3;
        this.player.invincible = 0;
        this.player.skills = {
            dash:{cd:0,active:false}, shield:{cd:0,active:false}, magnet:{cd:0,active:false}, sonar:{cd:0,active:false}
        };

        this.enemies = [];
        this.particles = [];
        this.state = 'PLAY';
        
        UI.setupHUD(cfg);
        this.loop();
    },

    retry() { this.start(this.levelIdx, this.saveId); },

    loop() {
        if(this.state !== 'PLAY') return;

        // 1. æ¸…ç©ºç”»å¸ƒ
        this.ctx.clearRect(0, 0, this.W, this.H);
        
        this.update();
        this.draw();

        this.loopId = requestAnimationFrame(() => this.loop());
    },

    update() {
        const p = this.player;
        const lvl = CFG.LEVELS[this.levelIdx];
        const dt = 16;

        // --- ç©å®¶æ§åˆ¶ ---
        let acc = 0.6;
        let drag = 0.94;
        let maxSpd = 8 * (30 / (p.r + 20)); // ä½“å‹è¶Šå¤§è¶Šæ…¢
        
        if(p.skills.dash.active) maxSpd *= 2.5;

        if(this.keys['ArrowUp'] || this.keys['w']) p.vy -= acc;
        if(this.keys['ArrowDown'] || this.keys['s']) p.vy += acc;
        if(this.keys['ArrowLeft'] || this.keys['a']) p.vx -= acc;
        if(this.keys['ArrowRight'] || this.keys['d']) p.vx += acc;

        p.vx *= drag; p.vy *= drag;
        // é™é€Ÿ
        const spd = Math.sqrt(p.vx**2 + p.vy**2);
        if(spd > maxSpd) { p.vx = (p.vx/spd)*maxSpd; p.vy = (p.vy/spd)*maxSpd; }

        p.x += p.vx; p.y += p.vy;
        
        // ä¸–ç•Œè¾¹ç•Œé™åˆ¶
        if(p.x < p.r) p.x=p.r; if(p.x > CFG.WORLD_SIZE-p.r) p.x=CFG.WORLD_SIZE-p.r;
        if(p.y < p.r) p.y=p.r; if(p.y > CFG.WORLD_SIZE-p.r) p.y=CFG.WORLD_SIZE-p.r;

        // è®¡ç®—è§’åº¦
        if(spd > 0.1) p.angle = Math.atan2(p.vy, p.vx);
        
        // æ›´æ–°éª¨éª¼
        p.updateBody(spd);

        // --- æ‘„åƒæœºè·Ÿéš ---
        // ç›®æ ‡æ˜¯è®©ç©å®¶åœ¨å±å¹•ä¸­é—´: CamX = P.x - ScreenW/2
        let targetCamX = p.x - this.W/2;
        let targetCamY = p.y - this.H/2;
        // å¹³æ»‘ç§»åŠ¨ (Lerp)
        this.cam.x += (targetCamX - this.cam.x) * 0.1;
        this.cam.y += (targetCamY - this.cam.y) * 0.1;
        
        // éœ‡åŠ¨è¡°å‡
        if(this.shake > 0) this.shake *= 0.9;

        // --- æ•Œäººç”Ÿæˆ ---
        if(this.enemies.length < 25 && Math.random() < 0.03) {
            this.spawnEnemy(lvl);
        }

        // --- æ•Œäººé€»è¾‘ ---
        for(let i = this.enemies.length-1; i>=0; i--) {
            let e = this.enemies[i];
            
            // AI
            if(e.stunned > 0) {
                e.stunned--; e.vx *= 0.9; e.vy *= 0.9;
            } else {
                // é²¨é±¼è¿½å‡»
                if(e.aggro && !p.skills.shield.active) {
                    const dx = p.x - e.x, dy = p.y - e.y;
                    const d = Math.sqrt(dx*dx + dy*dy);
                    if(d < 800) { e.vx += (dx/d)*0.25; e.vy += (dy/d)*0.25; }
                }
                // ç£å¸
                if(p.skills.magnet.active && e.r < p.r) {
                    const dx = p.x - e.x, dy = p.y - e.y;
                    const d = Math.sqrt(dx*dx + dy*dy);
                    if(d < CFG.SKILLS.magnet.r) { e.vx += (dx/d)*0.8; e.vy += (dy/d)*0.8; }
                }
                
                e.x += e.vx; e.y += e.vy;
            }
            
            const espd = Math.sqrt(e.vx**2 + e.vy**2);
            if(espd > 0.1) e.angle = Math.atan2(e.vy, e.vx);
            e.updateBody(espd);

            // ç¢°æ’æ£€æµ‹
            const dist = Math.sqrt((p.x-e.x)**2 + (p.y-e.y)**2);
            
            if(dist < p.r + e.r * 0.8) {
                if(p.r > e.r * 1.1) {
                    // åƒæ‰
                    this.enemies.splice(i, 1);
                    p.r += e.r * 0.08;
                    this.spawnParticles(e.x, e.y, e.color);
                    UI.floatText(`+${Math.floor(e.r)}`, e.x - this.cam.x, e.y - this.cam.y, '#ffd700');
                    UI.updateStats();
                    if(p.r >= lvl.target) { this.state = 'PAUSED'; UI.showPanel('p-win'); }
                } else if (e.r > p.r) {
                    // å—ä¼¤
                    if(p.invincible <= 0 && !p.skills.shield.active) {
                        p.lives--; p.invincible = 120; this.shake = 20;
                        UI.floatText("å±é™©!", p.x - this.cam.x, p.y - 50 - this.cam.y, '#ff0055');
                        UI.updateStats();
                        if(p.lives <= 0) { this.state = 'OVER'; UI.showPanel('p-dead'); }
                    }
                }
            }
            
            // è·ç¦»å¤ªè¿œé”€æ¯
            const distToCam = Math.sqrt((e.x - p.x)**2 + (e.y - p.y)**2);
            if(distToCam > 2000) this.enemies.splice(i, 1);
        }

        if(p.invincible > 0) p.invincible--;

        // --- ç²’å­æ›´æ–° ---
        for(let i=this.particles.length-1; i>=0; i--) {
            let pt = this.particles[i];
            pt.x += pt.vx; pt.y += pt.vy; pt.life -= 0.03;
            if(pt.life <= 0) this.particles.splice(i,1);
        }

        // --- æŠ€èƒ½CD ---
        for(let k in p.skills) {
            if(p.skills[k].cd > 0) {
                p.skills[k].cd -= dt;
                UI.updateCD(k, p.skills[k].cd);
            }
        }
    },

    draw() {
        const ctx = this.ctx;
        const p = this.player;
        const lvl = CFG.LEVELS[this.levelIdx];

        // åº”ç”¨æ‘„åƒæœºå˜æ¢
        ctx.save();
        // éœ‡åŠ¨æ•ˆæœ
        let sx = (Math.random()-0.5) * this.shake;
        let sy = (Math.random()-0.5) * this.shake;
        ctx.translate(-this.cam.x + sx, -this.cam.y + sy);

        // 1. èƒŒæ™¯ (è§†å·®èƒŒæ™¯æˆ–ç½‘æ ¼)
        const g = ctx.createLinearGradient(0,0,0,CFG.WORLD_SIZE);
        g.addColorStop(0, lvl.bg[0]); g.addColorStop(1, lvl.bg[1]);
        ctx.fillStyle = g;
        ctx.fillRect(0,0,CFG.WORLD_SIZE, CFG.WORLD_SIZE);
        
        // ç»˜åˆ¶ä¸–ç•Œè¾¹ç•Œ
        ctx.strokeStyle = 'rgba(255,255,255,0.1)';
        ctx.lineWidth = 10;
        ctx.strokeRect(0,0,CFG.WORLD_SIZE,CFG.WORLD_SIZE);

        // 2. æ·±æµ·å…‰ç…§å±‚
        if(lvl.dark > 0) {
            // å…ˆç”»æ•´ä¸ªé»‘å±‚
            ctx.fillStyle = `rgba(0,0,0,${lvl.dark})`;
            ctx.fillRect(this.cam.x, this.cam.y, this.W, this.H); // ä¼˜åŒ–ï¼šåªç”»å±å¹•èŒƒå›´
            
            ctx.globalCompositeOperation = 'destination-out';
            
            // ç©å®¶è§†é‡
            this.drawLight(p.x, p.y, p.r*5+300);
            
            // ç¯ç¬¼é±¼è§†é‡
            this.enemies.forEach(e => {
                if(e.type === 'angler') this.drawLight(e.x, e.y, e.r*4+100);
            });
            
            ctx.globalCompositeOperation = 'source-over';
        }

        // 3. æŠ€èƒ½ç‰¹æ•ˆ
        if(p.skills.shield.active) {
            ctx.strokeStyle = '#ffd700'; ctx.lineWidth = 4; ctx.setLineDash([10,5]);
            ctx.beginPath(); ctx.arc(p.x, p.y, p.r+25, 0, Math.PI*2); ctx.stroke(); ctx.setLineDash([]);
        }
        if(p.skills.magnet.active) {
            ctx.strokeStyle = 'rgba(189,0,255,0.3)'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.arc(p.x, p.y, CFG.SKILLS.magnet.r, 0, Math.PI*2); ctx.stroke();
        }
        if(p.skills.sonar.active) {
            ctx.strokeStyle = '#fff'; ctx.lineWidth = 20;
            ctx.beginPath(); ctx.arc(p.x, p.y, CFG.SKILLS.sonar.r, 0, Math.PI*2); ctx.stroke();
        }

        // 4. å®ä½“ç»˜åˆ¶
        this.enemies.forEach(e => e.draw(ctx));
        
        // ç©å®¶ (é—ªçƒæ— æ•Œ)
        if(p.invincible%10 < 5) p.draw(ctx);

        // 5. ç²’å­
        this.particles.forEach(pt => {
            ctx.globalAlpha = pt.life; ctx.fillStyle = pt.color;
            ctx.beginPath(); ctx.arc(pt.x, pt.y, pt.r, 0, Math.PI*2); ctx.fill();
        });
        ctx.globalAlpha = 1;

        ctx.restore(); // ç»“æŸæ‘„åƒæœº
    },

    drawLight(x, y, r) {
        const g = this.ctx.createRadialGradient(x, y, r*0.1, x, y, r);
        g.addColorStop(0, 'rgba(0,0,0,1)');
        g.addColorStop(1, 'rgba(0,0,0,0)');
        this.ctx.fillStyle = g;
        this.ctx.beginPath(); this.ctx.arc(x, y, r, 0, Math.PI*2); this.ctx.fill();
    },

    spawnEnemy(lvl) {
        const key = lvl.spawns[Math.floor(Math.random()*lvl.spawns.length)];
        const proto = CFG.FISH[key];
        
        // åœ¨å±å¹•å¤–ç”Ÿæˆ
        let ex, ey;
        if(Math.random()>0.5) {
            ex = this.player.x + (Math.random()>0.5?1:-1) * (this.W/2 + 200);
            ey = this.player.y + (Math.random()-0.5) * this.H;
        } else {
            ex = this.player.x + (Math.random()-0.5) * this.W;
            ey = this.player.y + (Math.random()>0.5?1:-1) * (this.H/2 + 200);
        }
        
        // è¾¹ç•Œæ£€æŸ¥
        if(ex<0) ex=0; if(ex>CFG.WORLD_SIZE) ex=CFG.WORLD_SIZE;
        if(ey<0) ey=0; if(ey>CFG.WORLD_SIZE) ey=CFG.WORLD_SIZE;

        let r = proto.r[0] + Math.random()*(proto.r[1]-proto.r[0]);
        // åŠ¨æ€éš¾åº¦
        if(this.player.r > 100 && Math.random()<0.3 && !proto.aggro) r *= 1.5;

        const e = new FishEntity(ex, ey, r, proto.color, proto.type);
        // ç»™ä¸ªåˆå§‹é€Ÿåº¦
        e.vx = (Math.random()-0.5)*proto.spd;
        e.vy = (Math.random()-0.5)*proto.spd;
        e.aggro = proto.aggro;
        e.stunned = 0;
        
        this.enemies.push(e);
    },

    spawnParticles(x, y, color) {
        for(let i=0; i<8; i++) {
            this.particles.push({
                x:x, y:y, r:Math.random()*5+2, color:color, life:1,
                vx:(Math.random()-0.5)*10, vy:(Math.random()-0.5)*10
            });
        }
    },

    skill(key) {
        if(!CFG.LEVELS[this.levelIdx].skills.includes(key)) return;
        const s = this.player.skills[key];
        const sc = CFG.SKILLS[key];
        
        if(s.cd <= 0 && !s.active) {
            s.active = true; s.cd = sc.cd;
            if(key==='sonar') {
                this.shake = 30;
                this.enemies.forEach(e => e.stunned = 180);
                UI.floatText("SONAR!", this.player.x - this.cam.x, this.player.y - 50 - this.cam.y, '#fff');
            } else {
                UI.floatText(key.toUpperCase(), this.player.x - this.cam.x, this.player.y - 50 - this.cam.y, sc.color);
            }
            setTimeout(() => s.active = false, sc.dur);
        }
    }
};

/* --- UI ç®¡ç† --- */
const UI = {
    panels: {
        pass: document.getElementById('p-pass'),
        login: document.getElementById('p-login'),
        saves: document.getElementById('p-saves'),
        hud: document.getElementById('hud'),
        win: document.getElementById('p-win'),
        dead: document.getElementById('p-dead')
    },

    show(key) {
        Object.values(this.panels).forEach(p => p.classList.remove('active'));
        if(key && this.panels[key]) this.panels[key].classList.add('active');
    },

    handleEnter() {
        if(this.panels.pass.classList.contains('active')) this.verifyPass();
        else if(this.panels.login.classList.contains('active')) this.login();
    },

    verifyPass() {
        const v = document.getElementById('inp-pass').value;
        if(v === CFG.PASS) this.show('login');
        else {
            const el = document.getElementById('inp-pass');
            el.classList.add('error-shake');
            setTimeout(() => el.classList.remove('error-shake'), 400);
            el.value = '';
        }
    },

    login() {
        const v = document.getElementById('inp-user').value.toUpperCase().trim();
        if(v && /^[A-Z]+$/.test(v)) {
            App.user = v;
            App.loadSaves();
        } else alert("è¯·è¾“å…¥æœ‰æ•ˆçš„æ‹¼éŸ³ä»£å·");
    },

    setupHUD(lvl) {
        this.show('hud');
        document.getElementById('ui-target').innerText = lvl.target;
        document.getElementById('ui-zone').innerText = lvl.name;
        
        ['dash','shield','magnet','sonar'].forEach(s => {
            document.getElementById(`s-${s}`).style.display = lvl.skills.includes(s) ? 'flex' : 'none';
        });
        this.updateStats();
    },

    updateStats() {
        document.getElementById('ui-size').innerText = Math.floor(Game.player.r);
        document.getElementById('ui-lives').innerText = Game.player.lives;
    },

    updateCD(key, cd) {
        const max = CFG.SKILLS[key].cd;
        const pct = (cd/max)*100;
        document.getElementById(`cd-${key}`).style.height = pct + '%';
        const slot = document.getElementById(`s-${key}`);
        if(cd<=0) slot.classList.add('active'); else slot.classList.remove('active');
    },

    floatText(txt, screenX, screenY, color) {
        const d = document.createElement('div');
        d.className = 'float-text'; d.innerText = txt;
        d.style.left = screenX + this.panels.pass.offsetWidth/2 + 'px'; // ä¿®æ­£å®šä½
        d.style.left = (screenX + window.innerWidth/2) + 'px'; // ç®€åŒ–ä¿®æ­£
        d.style.left = screenX + 'px'; 
        // ä¿®æ­£ä¸ºç»å¯¹å®šä½
        d.style.left = Math.max(0, Math.min(window.innerWidth, screenX)) + 'px';
        d.style.top = Math.max(0, Math.min(window.innerHeight, screenY)) + 'px';
        d.style.color = color;
        document.getElementById('ui-layer').appendChild(d);
        setTimeout(() => d.remove(), 800);
    }
};

/* --- App é€»è¾‘ --- */
const App = {
    user: null,

    loadSaves() {
        UI.show('saves');
        document.getElementById('txt-welcome').innerText = `æ¬¢è¿å›æ¥ï¼ŒæŒ‡æŒ¥å®˜ ${this.user}`;
        const list = document.getElementById('slot-list');
        list.innerHTML = '';
        
        const saves = this.getStorage();
        if(saves.length===0) list.innerHTML = '<div style="color:#666">æš‚æ— è®°å½•</div>';
        
        saves.forEach(s => {
            const d = document.createElement('div');
            d.className = 'slot-item';
            d.innerHTML = `
                <div onclick="Game.start(${s.level}, ${s.id})">
                    <div style="font-weight:bold; color:var(--accent)">${CFG.LEVELS[s.level].name}</div>
                    <div style="font-size:0.8rem; color:#888">åˆ†æ•°: ${Math.floor(s.score)} | ${s.date}</div>
                </div>
                <div class="del-btn" onclick="App.del(${s.id})">Ã—</div>
            `;
            list.appendChild(d);
        });
    },

    getStorage() {
        const r = SafeStorage.get(`DSE_${this.user}`);
        return r ? JSON.parse(r) : [];
    },

    save(lvl, score) {
        let saves = this.getStorage();
        const now = new Date().toLocaleDateString();
        
        if(Game.saveId) {
            const idx = saves.findIndex(s=>s.id === Game.saveId);
            if(idx>-1) { saves[idx].level=lvl; saves[idx].score=score; saves[idx].date=now; }
        } else {
            Game.saveId = Date.now();
            if(saves.length >= 4) saves.shift();
            saves.push({id:Game.saveId, level:lvl, score:score, date:now});
        }
        SafeStorage.set(`DSE_${this.user}`, JSON.stringify(saves));
    },

    del(id) {
        if(!confirm('åˆ é™¤å­˜æ¡£?')) return;
        let s = this.getStorage().filter(i=>i.id !== id);
        SafeStorage.set(`DSE_${this.user}`, JSON.stringify(s));
        this.loadSaves();
    },

    newGame() { Game.start(0, null); },
    logout() { this.user=null; UI.show('login'); },
    nextLevel() { 
        this.save(Game.levelIdx+1, Game.player.r); 
        Game.start(Game.levelIdx+1, Game.saveId); 
    },
    saveAndQuit() {
        this.save(Math.min(Game.levelIdx+1, 1), Game.player.r);
        this.loadSaves();
    }
};

// å¯åŠ¨å…¥å£ï¼šç¡®ä¿DOMåŠ è½½å®Œæ¯•
window.onload = function() {
    Game.init();
    // åˆå§‹æ˜¾ç¤º
    UI.show('pass');
};
</script>
</body>
</html>
