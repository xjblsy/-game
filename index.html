<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>æ·±æµ·éœ¸ä¸»ï¼šæ·±æ¸Šè§‰é†’</title>
    <style>
        :root {
            --primary: #00f2fe;
            --secondary: #4facfe;
            --accent: #ffd700;
            --danger: #ff4757;
            --dark: #0a192f;
            --glass: rgba(16, 33, 60, 0.95);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; font-family: "Microsoft YaHei", sans-serif; user-select: none; }
        
        body { 
            background: #000; 
            overflow: hidden; 
            width: 100vw; 
            height: 100vh;
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* æ¸¸æˆç”»å¸ƒå±‚ */
        #gameLayer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        
        /* UI å±‚ */
        #uiLayer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; pointer-events: none; }

        /* é€šç”¨é¢æ¿æ ·å¼ */
        .panel {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: var(--glass);
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 0 50px rgba(0,242,254,0.2);
            backdrop-filter: blur(10px);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            min-width: 400px;
            pointer-events: auto;
            display: none; /* é»˜è®¤éšè— */
            animation: floatIn 0.5s ease;
        }

        @keyframes floatIn { from { opacity: 0; transform: translate(-50%, -40%); } to { opacity: 1; transform: translate(-50%, -50%); } }

        h1 { 
            font-size: 2.5rem; 
            background: linear-gradient(to right, var(--primary), var(--secondary)); 
            -webkit-background-clip: text; 
            -webkit-text-fill-color: transparent;
            margin-bottom: 20px;
        }

        input {
            background: rgba(0,0,0,0.5);
            border: 1px solid #333;
            padding: 15px;
            width: 100%;
            color: #fff;
            font-size: 1.2rem;
            border-radius: 10px;
            text-align: center;
            margin-bottom: 20px;
            text-transform: uppercase;
        }
        input:focus { outline: none; border-color: var(--primary); }

        .btn {
            background: linear-gradient(135deg, var(--secondary), #0072ff);
            border: none;
            padding: 12px 30px;
            color: white;
            font-size: 1.1rem;
            font-weight: bold;
            border-radius: 50px;
            cursor: pointer;
            transition: 0.2s;
            margin: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        .btn:hover { transform: scale(1.05); filter: brightness(1.2); }
        .btn:active { transform: scale(0.95); }
        .btn.danger { background: linear-gradient(135deg, #ff416c, #ff4b2b); }
        .btn.success { background: linear-gradient(135deg, #11998e, #38ef7d); }

        /* å­˜æ¡£åˆ—è¡¨ */
        .slot-list { margin-bottom: 20px; max-height: 300px; overflow-y: auto; }
        .slot-item {
            background: rgba(255,255,255,0.05);
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border: 1px solid transparent;
            transition: 0.2s;
        }
        .slot-item:hover { border-color: var(--primary); background: rgba(255,255,255,0.1); }
        .slot-info { text-align: left; cursor: pointer; flex-grow: 1; }
        .slot-title { font-weight: bold; color: var(--accent); }
        .slot-date { font-size: 0.8rem; color: #888; }
        .delete-icon { color: var(--danger); font-weight: bold; padding: 5px 10px; cursor: pointer; }

        /* HUD (æ¸¸æˆç•Œé¢) */
        .hud-top { position: absolute; top: 20px; left: 20px; pointer-events: none; }
        .stat-box { background: rgba(0,0,0,0.6); padding: 10px 20px; border-radius: 30px; margin-bottom: 10px; border-left: 4px solid var(--primary); display: inline-block; clear: both; float: left; }
        
        /* æŠ€èƒ½æ  */
        .skill-bar { 
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); 
            display: flex; gap: 20px; pointer-events: auto;
        }
        .skill-icon {
            width: 60px; height: 60px; background: rgba(0,0,0,0.8); border: 2px solid #555; border-radius: 12px;
            position: relative; overflow: hidden; display: flex; align-items: center; justify-content: center;
            font-size: 1.5rem; color: #fff; transition: 0.2s;
        }
        .skill-icon.active { border-color: var(--accent); box-shadow: 0 0 20px var(--accent); transform: scale(1.1); }
        .skill-key { position: absolute; bottom: 2px; right: 4px; font-size: 0.7rem; color: #aaa; }
        .cooldown { position: absolute; bottom: 0; left: 0; width: 100%; height: 0%; background: rgba(0,0,0,0.7); transition: height 0.1s linear; }

        /* æµ®åŠ¨æ–‡å­— */
        .floating-text {
            position: absolute; font-weight: bold; font-size: 1.2rem; pointer-events: none;
            animation: floatUp 1s forwards; text-shadow: 0 0 5px black;
        }
        @keyframes floatUp { 0% { opacity:1; transform:translateY(0); } 100% { opacity:0; transform:translateY(-50px); } }

        /* å…³å¡é®ç½© (æ·±æµ·æ¨¡å¼) */
        #darknessOverlay { display: none; }
    </style>
</head>
<body>

    <canvas id="gameLayer"></canvas>

    <div id="uiLayer">
        
        <div id="loginPanel" class="panel" style="display: block;">
            <h1>æ·±æµ·éœ¸ä¸»</h1>
            <p style="color: #aaa; margin-bottom: 15px;">è¾“å…¥æ‚¨çš„ä»£å· (æ‹¼éŸ³é¦–å­—æ¯)</p>
            <input type="text" id="username" placeholder="ä¾‹å¦‚: LZY" maxlength="10">
            <button class="btn" id="btnLogin">è¿›å…¥ç³»ç»Ÿ</button>
        </div>

        <div id="menuPanel" class="panel">
            <h2>æ¡£æ¡ˆé€‰æ‹©</h2>
            <div id="welcomeMsg" style="margin-bottom: 15px; color: var(--secondary);"></div>
            <div class="slot-list" id="slotContainer">
                </div>
            <button class="btn success" id="btnNewGame">åˆ›å»ºæ–°æ¸¸æˆ</button>
            <button class="btn danger" id="btnLogout">é€€å‡ºç™»å½•</button>
        </div>

        <div id="transitionPanel" class="panel">
            <h2 id="transTitle" style="color: var(--accent);">æ­å–œéœ¸ä¸»!</h2>
            <p id="transDesc">ä½ å·²ç»Ÿæ²»è¿™ç‰‡æµ…æ»©ï¼Œä½†æ·±æµ·åœ¨å‘¼å”¤...</p>
            <div style="margin: 30px 0;">
                <p>ä¸‹ä¸€å…³: <span style="color:var(--danger); font-weight:bold;">æ·±æµ·ç¦åŒº</span></p>
                <p style="font-size:0.9rem; color:#aaa;">æ–°å¢: è§†é‡é™åˆ¶, ä¸»åŠ¨æ”»å‡»æ€ªç‰©, å£°çº³æŠ€èƒ½</p>
            </div>
            <button class="btn success" id="btnContinue">ç»§ç»­æŒ‘æˆ˜</button>
            <button class="btn" id="btnSaveQuit">å­˜æ¡£å¹¶ä¼‘æ¯</button>
        </div>

        <div id="gameOverPanel" class="panel">
            <h1 style="color: var(--danger);">ä½ è¢«åå™¬äº†</h1>
            <p>æ·±æµ·æ˜¯æ®‹é…·çš„...</p>
            <button class="btn" onclick="Game.restartLevel()">é‡æ–°æŒ‘æˆ˜æœ¬å…³</button>
            <button class="btn danger" onclick="UI.showMenu()">è¿”å›ä¸»èœå•</button>
        </div>

        <div id="hud" style="display: none;">
            <div class="hud-top">
                <div class="stat-box">ç”Ÿå‘½: <span id="uiLives" style="color: var(--danger);">â¤â¤â¤</span></div>
                <div class="stat-box">ä½“å‹: <span id="uiSize">0</span> / <span id="uiTarget">0</span></div>
                <div class="stat-box">å…³å¡: <span id="uiLevelName">æµ…æ»©</span></div>
            </div>

            <div class="skill-bar">
                <div class="skill-icon" id="skillDash">
                    âš¡<span class="skill-key">SPACE</span>
                    <div class="cooldown" id="cdDash"></div>
                </div>
                <div class="skill-icon" id="skillSonar" style="display: none;">
                    ğŸ”Š<span class="skill-key">E</span>
                    <div class="cooldown" id="cdSonar"></div>
                </div>
            </div>
        </div>
    </div>

<script>
/**
 * æ¸¸æˆæ ¸å¿ƒä»£ç 
 * åŒ…å«ï¼šå­˜æ¡£ç®¡ç†ã€å…³å¡è®¾è®¡ã€ç‰©ç†å¼•æ“ã€AIé€»è¾‘ã€æ¸²æŸ“ç³»ç»Ÿ
 */

// --- é…ç½® ---
const CONFIG = {
    maxSaves: 4,
    levels: [
        {   // å…³å¡ 0: æµ…æ»©
            name: "é˜³å…‰æµ…æ»©",
            bgColors: ["#00c6ff", "#0072ff"],
            targetSize: 50,
            startSize: 15,
            visibility: 1.0, // å…¨äº®
            drag: 0.96, // æ°´é˜»åŠ›
            skills: ['dash'],
            enemies: ['fish_small', 'fish_medium']
        },
        {   // å…³å¡ 1: æ·±æµ·
            name: "æ·±æµ·ç¦åŒº",
            bgColors: ["#0f0c29", "#302b63"],
            targetSize: 150,
            startSize: 55,
            visibility: 0.15, // é»‘æš—æ¨¡å¼
            drag: 0.94, // é˜»åŠ›æ›´å¤§
            skills: ['dash', 'sonar'],
            enemies: ['fish_medium', 'angler', 'shark', 'whale']
        }
    ],
    skills: {
        dash: { cd: 3000, duration: 300, power: 3.5 },
        sonar: { cd: 8000, duration: 1500, range: 300 } // çœ©æ™•èŒƒå›´
    }
};

// --- å­˜å‚¨ç³»ç»Ÿ ---
const SaveSystem = {
    user: null,
    
    getKey() { return `DS_SAVE_${this.user}`; },

    getAllSaves() {
        if(!this.user) return [];
        const raw = localStorage.getItem(this.getKey());
        return raw ? JSON.parse(raw) : [];
    },

    saveProgress(slotId, levelIdx, score) {
        let saves = this.getAllSaves();
        const now = new Date().toLocaleString();
        
        // å¦‚æœæ˜¯æ–°å­˜æ¡£
        if (slotId === null) {
            slotId = Date.now();
            saves.push({ id: slotId, level: levelIdx, score: score, date: now });
        } else {
            // è¦†ç›–æ—§å­˜æ¡£
            const idx = saves.findIndex(s => s.id === slotId);
            if (idx !== -1) {
                saves[idx].level = levelIdx;
                saves[idx].score = score;
                saves[idx].date = now;
            } else {
                saves.push({ id: slotId, level: levelIdx, score: score, date: now });
            }
        }
        localStorage.setItem(this.getKey(), JSON.stringify(saves));
        return slotId;
    },

    deleteSave(id) {
        let saves = this.getAllSaves();
        saves = saves.filter(s => s.id !== id);
        localStorage.setItem(this.getKey(), JSON.stringify(saves));
    }
};

// --- æ¸¸æˆå¼•æ“ ---
const Game = {
    canvas: document.getElementById('gameLayer'),
    ctx: document.getElementById('gameLayer').getContext('2d'),
    width: window.innerWidth,
    height: window.innerHeight,
    loopId: null,
    state: 'MENU', // MENU, PLAYING, PAUSED, OVER
    
    currentSaveId: null,
    levelIdx: 0,
    
    player: {
        x: 0, y: 0, vx: 0, vy: 0, r: 0, angle: 0,
        color: '#00f2fe', lives: 3, score: 0, invincible: 0,
        skills: { dash: {cd:0, active:false}, sonar: {cd:0, active:false} }
    },
    
    enemies: [],
    particles: [],
    keys: {},

    init() {
        window.addEventListener('resize', () => this.resize());
        this.resize();
        this.bindInput();
        
        // ç²’å­å¾ªç¯æ¸…ç†
        setInterval(() => {
            if(this.state !== 'PLAYING') return;
            this.particles = this.particles.filter(p => p.life > 0);
        }, 1000);
    },

    resize() {
        this.width = window.innerWidth;
        this.height = window.innerHeight;
        this.canvas.width = this.width;
        this.canvas.height = this.height;
    },

    startLevel(lvlIdx, saveId) {
        this.levelIdx = lvlIdx;
        this.currentSaveId = saveId;
        const cfg = CONFIG.levels[lvlIdx];
        
        // åˆå§‹åŒ–ç©å®¶
        this.player.x = this.width / 2;
        this.player.y = this.height / 2;
        this.player.vx = 0; this.player.vy = 0;
        this.player.r = cfg.startSize;
        this.player.lives = 3;
        this.player.invincible = 0;
        // æ¸…ç©ºæŠ€èƒ½CD
        this.player.skills.dash.cd = 0;
        this.player.skills.sonar.cd = 0;

        this.enemies = [];
        this.particles = [];
        this.state = 'PLAYING';

        UI.updateHUD(cfg);
        UI.hideAllPanels();
        document.getElementById('hud').style.display = 'block';

        if(this.loopId) cancelAnimationFrame(this.loopId);
        this.loop();
    },

    restartLevel() {
        this.startLevel(this.levelIdx, this.currentSaveId);
    },

    loop() {
        if (this.state !== 'PLAYING') return;

        // æ¸…ç©º
        this.ctx.clearRect(0, 0, this.width, this.height);

        this.update();
        this.draw();

        this.loopId = requestAnimationFrame(() => this.loop());
    },

    update() {
        const p = this.player;
        const cfg = CONFIG.levels[this.levelIdx];
        const drag = cfg.drag;

        // 1. ç©å®¶ç§»åŠ¨
        let speed = 0.5; // åŠ é€Ÿåº¦
        let maxSpeed = 6 * (30 / (p.r + 10)); // ä½“å‹è¶Šå¤§è¶Šæ…¢
        
        if (p.skills.dash.active) maxSpeed *= CONFIG.skills.dash.power;

        if (this.keys['ArrowUp'] || this.keys['w']) p.vy -= speed;
        if (this.keys['ArrowDown'] || this.keys['s']) p.vy += speed;
        if (this.keys['ArrowLeft'] || this.keys['a']) p.vx -= speed;
        if (this.keys['ArrowRight'] || this.keys['d']) p.vx += speed;

        // æ‘©æ“¦åŠ›
        p.vx *= drag; p.vy *= drag;
        
        // æ›´æ–°ä½ç½®
        p.x += p.vx; p.y += p.vy;

        // è¾¹ç•Œ
        if(p.x < p.r) { p.x = p.r; p.vx *= -1; }
        if(p.x > this.width - p.r) { p.x = this.width - p.r; p.vx *= -1; }
        if(p.y < p.r) { p.y = p.r; p.vy *= -1; }
        if(p.y > this.height - p.r) { p.y = this.height - p.r; p.vy *= -1; }

        // è§’åº¦
        const vel = Math.sqrt(p.vx*p.vx + p.vy*p.vy);
        if (vel > 0.1) p.angle = Math.atan2(p.vy, p.vx);

        // 2. æ•Œäººç”Ÿæˆ
        if (this.enemies.length < 15 && Math.random() < 0.02) {
            this.spawnEnemy(cfg);
        }

        // 3. æ•Œäººé€»è¾‘
        this.enemies.forEach((e, i) => {
            // AI: é²¨é±¼è¿½è¸ª
            if (e.type === 'shark' && !e.stunned) {
                const dx = p.x - e.x;
                const dy = p.y - e.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < 500) { // è§†é‡
                    e.vx += (dx/dist) * 0.15;
                    e.vy += (dy/dist) * 0.15;
                }
            }

            // çœ©æ™•çŠ¶æ€
            if (e.stunned > 0) {
                e.stunned--;
                e.vx *= 0.9; e.vy *= 0.9;
            } else {
                e.x += e.vx; e.y += e.vy;
            }

            // å‡ºç•Œç§»é™¤
            if (e.x < -200 || e.x > this.width + 200) this.enemies.splice(i, 1);

            // ç¢°æ’æ£€æµ‹
            const dx = p.x - e.x;
            const dy = p.y - e.y;
            const dist = Math.sqrt(dx*dx + dy*dy);

            if (dist < p.r + e.r * 0.9) {
                if (p.r > e.r * 1.1) {
                    // åƒæ‰
                    p.r += e.r * 0.08;
                    p.score += Math.floor(e.r);
                    UI.floatText(`+${Math.floor(e.r)}`, e.x, e.y, '#ffd700');
                    this.createExplosion(e.x, e.y, e.color);
                    this.enemies.splice(i, 1);
                    
                    // æ›´æ–°UI
                    document.getElementById('uiSize').innerText = Math.floor(p.r);

                    // æ£€æŸ¥è¿‡å…³
                    if (p.r >= cfg.targetSize) {
                        this.levelComplete();
                    }
                } else if (e.r > p.r) {
                    // å—ä¼¤
                    if (p.invincible <= 0 && !p.skills.dash.active) { // å†²åˆºæ—¶ä¹Ÿç¨å¾®æ— æ•Œä¸€ä¸‹
                        p.lives--;
                        p.invincible = 120; // 2ç§’
                        UI.updateLives();
                        UI.floatText("-1 ç”Ÿå‘½", p.x, p.y, '#ff4757');
                        this.createExplosion(p.x, p.y, '#ff0000');
                        // éœ‡åŠ¨ç‰¹æ•ˆ
                        document.body.style.transform = "translate(5px, 5px)";
                        setTimeout(()=> document.body.style.transform = "translate(0,0)", 50);

                        if (p.lives <= 0) {
                            this.state = 'OVER';
                            UI.showGameOver();
                        }
                    }
                }
            }
        });

        if (p.invincible > 0) p.invincible--;

        // 4. æŠ€èƒ½CD
        for (let k in p.skills) {
            if (p.skills[k].cd > 0) {
                p.skills[k].cd -= 16; // çº¦60fps
                UI.updateSkillCD(k);
            }
        }
    },

    spawnEnemy(cfg) {
        const type = cfg.enemies[Math.floor(Math.random() * cfg.enemies.length)];
        let e = { x: 0, y: Math.random() * this.height, vx: 0, vy: 0, r: 10, color: '#fff', type: type, stunned: 0 };
        
        // å·¦å³å‡ºç”Ÿ
        const left = Math.random() > 0.5;
        e.x = left ? -100 : this.width + 100;
        let dir = left ? 1 : -1;

        switch(type) {
            case 'fish_small':
                e.r = 5 + Math.random() * 10; e.color = '#ff9f43'; e.vx = 2 * dir;
                break;
            case 'fish_medium':
                e.r = 20 + Math.random() * 20; e.color = '#54a0ff'; e.vx = 1.5 * dir;
                break;
            case 'angler': // ç¯ç¬¼é±¼
                e.r = 30 + Math.random() * 15; e.color = '#a55eea'; e.vx = 1.2 * dir;
                break;
            case 'shark': // é²¨é±¼
                e.r = 45 + Math.random() * 30; e.color = '#636e72'; e.vx = 3.5 * dir;
                break;
            case 'whale': // é²¸é±¼
                e.r = 100 + Math.random() * 50; e.color = '#2d3436'; e.vx = 0.5 * dir;
                break;
        }
        
        // åŸºäºç©å®¶å¤§å°å¾®è°ƒæ•Œäººå¤§å°ï¼Œé˜²æ­¢ä¸€ç›´æ²¡æœ‰èƒ½åƒçš„
        // å¦‚æœç©å®¶å¾ˆå¤§ï¼Œå¢åŠ ç”Ÿæˆå¤§é±¼çš„æ¦‚ç‡ï¼ˆè¿™é‡Œç®€åŒ–å¤„ç†ï¼‰
        if (Math.random() < 0.3) e.r = this.player.r * (0.5 + Math.random() * 0.4); 

        this.enemies.push(e);
    },

    draw() {
        const ctx = this.ctx;
        const p = this.player;
        const cfg = CONFIG.levels[this.levelIdx];

        // 1. ç»˜åˆ¶èƒŒæ™¯
        const grad = ctx.createLinearGradient(0, 0, 0, this.height);
        grad.addColorStop(0, cfg.bgColors[0]);
        grad.addColorStop(1, cfg.bgColors[1]);
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, this.width, this.height);

        // 2. è§†é‡é™åˆ¶ï¼ˆæ·±æµ·æ•ˆæœï¼‰
        if (cfg.visibility < 1.0) {
            // å…ˆç”»é»‘
            ctx.fillStyle = `rgba(0,0,0,${1 - cfg.visibility})`;
            ctx.fillRect(0, 0, this.width, this.height);
            
            // æŒ–ç©ºï¼ˆç©å®¶å…‰ç¯ï¼‰
            ctx.globalCompositeOperation = 'destination-out';
            
            // ç©å®¶å‘¨å›´äº®
            const gradP = ctx.createRadialGradient(p.x, p.y, p.r, p.x, p.y, p.r + 300);
            gradP.addColorStop(0, 'rgba(0,0,0,1)');
            gradP.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = gradP;
            ctx.beginPath(); ctx.arc(p.x, p.y, p.r + 300, 0, Math.PI*2); ctx.fill();

            // ç¯ç¬¼é±¼äº®
            this.enemies.forEach(e => {
                if (e.type === 'angler') {
                    const gradE = ctx.createRadialGradient(e.x, e.y, e.r/2, e.x, e.y, e.r + 150);
                    gradE.addColorStop(0, 'rgba(0,0,0,1)');
                    gradE.addColorStop(1, 'rgba(0,0,0,0)');
                    ctx.fillStyle = gradE;
                    ctx.beginPath(); ctx.arc(e.x, e.y, e.r + 150, 0, Math.PI*2); ctx.fill();
                }
            });

            ctx.globalCompositeOperation = 'source-over';
        }

        // 3. ç»˜åˆ¶ç©å®¶
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate(p.angle);
        if (p.invincible > 0 && Math.floor(Date.now()/50)%2) ctx.globalAlpha = 0.5;

        // èº«ä½“
        ctx.beginPath();
        ctx.ellipse(0, 0, p.r, p.r * 0.7, 0, 0, Math.PI * 2);
        ctx.fillStyle = p.color;
        
        // å†²åˆºå˜è‰²
        if (p.skills.dash.active) {
            ctx.shadowBlur = 20; ctx.shadowColor = '#fff'; ctx.fillStyle = '#fff';
        }
        ctx.fill();
        ctx.shadowBlur = 0;

        // å°¾å·´
        ctx.beginPath();
        const tailWiggle = Math.sin(Date.now() / 100) * (p.r * 0.2);
        ctx.moveTo(-p.r * 0.8, 0);
        ctx.lineTo(-p.r * 1.8, -p.r * 0.6 + tailWiggle);
        ctx.lineTo(-p.r * 1.8, p.r * 0.6 + tailWiggle);
        ctx.fill();

        // å£°çº³ç‰¹æ•ˆ
        if (p.skills.sonar.active) {
             ctx.beginPath();
             ctx.arc(0, 0, CONFIG.skills.sonar.range, 0, Math.PI*2);
             ctx.strokeStyle = `rgba(255, 215, 0, ${Math.random()})`;
             ctx.lineWidth = 5;
             ctx.stroke();
        }

        ctx.restore();

        // 4. ç»˜åˆ¶æ•Œäºº
        this.enemies.forEach(e => {
            ctx.save();
            ctx.translate(e.x, e.y);
            // ç®€å•çš„æœå‘åˆ¤æ–­
            let angle = Math.atan2(e.vy, e.vx);
            if(Math.abs(e.vx) < 0.1 && e.type==='shark') angle = Math.atan2(p.y-e.y, p.x-e.x);
            ctx.rotate(angle);

            if (e.stunned > 0) ctx.globalAlpha = 0.4;

            ctx.fillStyle = e.color;
            ctx.beginPath();
            
            if (e.type === 'shark') {
                // é²¨é±¼ä¸‰è§’å½¢
                ctx.moveTo(e.r, 0); ctx.lineTo(-e.r, -e.r*0.6); ctx.lineTo(-e.r, e.r*0.6);
            } else if (e.type === 'whale') {
                // é²¸é±¼
                ctx.ellipse(0, 0, e.r, e.r*0.5, 0, 0, Math.PI*2);
            } else {
                // æ™®é€šé±¼
                ctx.ellipse(0, 0, e.r, e.r*0.7, 0, 0, Math.PI*2);
            }
            ctx.fill();
            
            // ç¯ç¬¼é±¼çš„ç¯
            if (e.type === 'angler') {
                ctx.beginPath(); ctx.moveTo(e.r*0.5, -e.r*0.5); ctx.lineTo(e.r*0.8, -e.r*1.2); 
                ctx.strokeStyle = '#fff'; ctx.stroke();
                ctx.beginPath(); ctx.arc(e.r*0.8, -e.r*1.2, 5, 0, Math.PI*2); 
                ctx.fillStyle = '#ffff00'; ctx.fill();
            }

            ctx.restore();
        });

        // 5. ç»˜åˆ¶ç²’å­
        this.particles.forEach(pt => {
            ctx.globalAlpha = pt.life;
            ctx.fillStyle = pt.color;
            ctx.beginPath(); ctx.arc(pt.x, pt.y, pt.r, 0, Math.PI*2); ctx.fill();
            pt.life -= 0.05;
            pt.x += pt.vx; pt.y += pt.vy;
        });
        ctx.globalAlpha = 1;
    },

    createExplosion(x, y, color) {
        for(let i=0; i<8; i++) {
            this.particles.push({
                x:x, y:y, r:Math.random()*5, color:color, 
                vx:(Math.random()-0.5)*10, vy:(Math.random()-0.5)*10, life:1
            });
        }
    },

    levelComplete() {
        this.state = 'PAUSED';
        UI.showTransition();
    },

    bindInput() {
        window.addEventListener('keydown', e => {
            this.keys[e.key] = true;
            if(this.state === 'PLAYING') {
                if(e.code === 'Space') this.useSkill('dash');
                if(e.code === 'KeyE') this.useSkill('sonar');
            }
        });
        window.addEventListener('keyup', e => this.keys[e.key] = false);
    },

    useSkill(name) {
        // æ£€æŸ¥å…³å¡æ˜¯å¦å…è®¸
        const cfg = CONFIG.levels[this.levelIdx];
        if (!cfg.skills.includes(name)) return;

        const skill = this.player.skills[name];
        const sCfg = CONFIG.skills[name];
        
        if (skill.cd <= 0 && !skill.active) {
            skill.active = true;
            skill.cd = sCfg.cd;
            
            if (name === 'sonar') {
                // éœ‡æ™•é€»è¾‘
                this.enemies.forEach(e => {
                    const d = Math.sqrt((e.x-this.player.x)**2 + (e.y-this.player.y)**2);
                    if (d < sCfg.range) e.stunned = 180; // 3ç§’
                });
                UI.floatText("å£°çº³å†²å‡»!", this.player.x, this.player.y - 50, '#ffd700');
            } else {
                UI.floatText("å†²åˆº!", this.player.x, this.player.y - 50, '#fff');
            }

            setTimeout(() => { skill.active = false; }, sCfg.duration);
        }
    }
};

// --- UI æ§åˆ¶ ---
const UI = {
    // DOM å…ƒç´ å¼•ç”¨
    loginPanel: document.getElementById('loginPanel'),
    menuPanel: document.getElementById('menuPanel'),
    transPanel: document.getElementById('transitionPanel'),
    gameLayer: document.getElementById('gameLayer'),

    init() {
        // ç»‘å®šæŒ‰é’®äº‹ä»¶
        document.getElementById('btnLogin').onclick = () => this.handleLogin();
        document.getElementById('btnLogout').onclick = () => this.handleLogout();
        document.getElementById('btnNewGame').onclick = () => this.handleNewGame();
        document.getElementById('btnContinue').onclick = () => this.handleNextLevel();
        document.getElementById('btnSaveQuit').onclick = () => this.handleSaveQuit();
    },

    hideAllPanels() {
        document.querySelectorAll('.panel').forEach(p => p.style.display = 'none');
    },

    handleLogin() {
        const name = document.getElementById('username').value.trim().toUpperCase();
        if(!name) return alert("è¯·è¾“å…¥ä»£å·");
        const regex = /^[A-Z]+$/;
        if(!regex.test(name)) return alert("ä»£å·åªèƒ½åŒ…å«å­—æ¯");
        
        SaveSystem.user = name;
        this.showMenu();
    },

    handleLogout() {
        SaveSystem.user = null;
        this.hideAllPanels();
        this.loginPanel.style.display = 'block';
    },

    showMenu() {
        this.hideAllPanels();
        this.menuPanel.style.display = 'block';
        document.getElementById('hud').style.display = 'none';
        document.getElementById('welcomeMsg').innerText = `æŒ‡æŒ¥å®˜ ${SaveSystem.user}, è¯·é€‰æ‹©è¡ŒåŠ¨æ¡£æ¡ˆ`;
        
        const container = document.getElementById('slotContainer');
        container.innerHTML = '';
        
        const saves = SaveSystem.getAllSaves();
        if(saves.length === 0) {
            container.innerHTML = '<div style="color:#aaa; padding:10px;">æš‚æ— æ¡£æ¡ˆ</div>';
        } else {
            saves.forEach(s => {
                const lvlName = CONFIG.levels[s.level] ? CONFIG.levels[s.level].name : "æœªçŸ¥æµ·åŸŸ";
                const item = document.createElement('div');
                item.className = 'slot-item';
                item.innerHTML = `
                    <div class="slot-info" onclick="Game.startLevel(${s.level}, ${s.id})">
                        <div class="slot-title">${lvlName} (Lv.${s.level+1})</div>
                        <div class="slot-date">åˆ†æ•°: ${s.score} | ${s.date}</div>
                    </div>
                    <div class="delete-icon" onclick="UI.deleteSlot(${s.id})">Ã—</div>
                `;
                container.appendChild(item);
            });
        }
    },

    deleteSlot(id) {
        if(confirm("ç¡®è®¤é”€æ¯æ­¤æ¡£æ¡ˆï¼Ÿ")) {
            SaveSystem.deleteSave(id);
            this.showMenu();
        }
    },

    handleNewGame() {
        const saves = SaveSystem.getAllSaves();
        if (saves.length >= CONFIG.maxSaves) return alert("æ¡£æ¡ˆå­˜å‚¨å·²æ»¡ï¼Œè¯·å…ˆåˆ é™¤æ—§æ¡£æ¡ˆ");
        Game.startLevel(0, null); // ä»ç¬¬0å…³å¼€å§‹ï¼Œæ— å­˜æ¡£ID
    },

    updateHUD(cfg) {
        document.getElementById('uiLevelName').innerText = cfg.name;
        document.getElementById('uiTarget').innerText = cfg.targetSize;
        document.getElementById('uiSize').innerText = cfg.startSize;
        
        // æŠ€èƒ½å›¾æ ‡æ˜¾ç¤ºé€»è¾‘
        document.getElementById('skillSonar').style.display = cfg.skills.includes('sonar') ? 'flex' : 'none';
        this.updateLives();
    },

    updateLives() {
        document.getElementById('uiLives').innerText = "â¤".repeat(Game.player.lives);
    },

    updateSkillCD(skillName) {
        const skill = Game.player.skills[skillName];
        const max = CONFIG.skills[skillName].cd;
        const domId = skillName === 'dash' ? 'cdDash' : 'cdSonar';
        const percent = (skill.cd / max) * 100;
        document.getElementById(domId).style.height = percent + '%';
        
        const iconId = skillName === 'dash' ? 'skillDash' : 'skillSonar';
        if (skill.cd <= 0) document.getElementById(iconId).classList.add('active');
        else document.getElementById(iconId).classList.remove('active');
    },

    showTransition() {
        this.hideAllPanels();
        this.transPanel.style.display = 'block';
        
        // æ£€æŸ¥æ˜¯å¦é€šå…³
        if (Game.levelIdx + 1 >= CONFIG.levels.length) {
            document.getElementById('transTitle').innerText = "æ·±æµ·éœ¸ä¸»é™ä¸´";
            document.getElementById('transDesc').innerText = "ä½ å·²å¾æœæ‰€æœ‰å·²çŸ¥æµ·åŸŸï¼";
            document.getElementById('btnContinue').style.display = 'none';
            document.getElementById('btnSaveQuit').innerText = "è£è€€å½’æ¡£";
        } else {
            document.getElementById('btnContinue').style.display = 'inline-block';
            document.getElementById('btnSaveQuit').innerText = "å­˜æ¡£å¹¶ä¼‘æ¯";
        }
    },

    handleNextLevel() {
        const nextIdx = Game.levelIdx + 1;
        // è‡ªåŠ¨å­˜æ¡£
        const saveId = SaveSystem.saveProgress(Game.currentSaveId, nextIdx, Game.player.score);
        Game.startLevel(nextIdx, saveId);
    },

    handleSaveQuit() {
        // ä¿å­˜å½“å‰è¿›åº¦çš„ä¸‹ä¸€å…³
        const nextIdx = Math.min(Game.levelIdx + 1, CONFIG.levels.length - 1);
        SaveSystem.saveProgress(Game.currentSaveId, nextIdx, Game.player.score);
        this.showMenu();
    },
    
    showGameOver() {
        this.hideAllPanels();
        document.getElementById('gameOverPanel').style.display = 'block';
    },

    floatText(text, x, y, color) {
        const el = document.createElement('div');
        el.className = 'floating-text';
        el.innerText = text;
        el.style.left = x + 'px';
        el.style.top = y + 'px';
        el.style.color = color;
        document.getElementById('uiLayer').appendChild(el);
        setTimeout(() => el.remove(), 1000);
    }
};

// å¯åŠ¨å…¥å£
window.onload = function() {
    Game.init();
    UI.init();
};

</script>
</body>
</html>
