<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Deep Sea Evolution: Stable</title>
    <style>
        :root {
            --primary: #00f2fe;
            --gold: #ffd700;
            --danger: #ff4757;
            --glass: rgba(15, 25, 40, 0.95);
        }

        body {
            margin: 0; padding: 0;
            background-color: #000;
            overflow: hidden;
            font-family: 'Segoe UI', sans-serif;
            color: white;
            width: 100vw; height: 100vh;
            display: flex; justify-content: center; align-items: center;
        }

        /* æ¸¸æˆå±‚ */
        canvas {
            position: absolute; top: 0; left: 0;
            z-index: 1; display: block;
        }

        /* UI å±‚ - å¿…é¡»æé«˜ */
        #ui-layer {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 999;
            pointer-events: none; /* å…è®¸ç‚¹å‡»ç©¿é€åˆ° Canvas */
        }

        /* é¢æ¿æ ·å¼ */
        .panel {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: var(--glass);
            border: 1px solid rgba(255,255,255,0.15);
            box-shadow: 0 0 40px rgba(0, 242, 254, 0.2);
            backdrop-filter: blur(10px);
            padding: 40px; border-radius: 16px;
            text-align: center; min-width: 350px;
            pointer-events: auto; /* æ¢å¤ç‚¹å‡» */
            display: none; /* é»˜è®¤éšè— */
        }

        /* å¼ºåˆ¶æ˜¾ç¤ºç¬¬ä¸€ä¸ªé¢æ¿ï¼Œé˜²æ­¢é»‘å± */
        #p-pass { display: block; }

        h1 { margin: 0 0 20px 0; font-size: 2rem; color: var(--primary); text-shadow: 0 0 10px var(--primary); }
        p { color: #aaa; margin-bottom: 20px; }

        input {
            background: rgba(0,0,0,0.6); border: 1px solid #444;
            color: #fff; padding: 12px; width: 100%; border-radius: 8px;
            font-size: 1.1rem; text-align: center; margin-bottom: 20px;
            outline: none;
        }
        input:focus { border-color: var(--primary); }

        .btn {
            background: linear-gradient(135deg, #00c6ff, #0072ff);
            border: none; padding: 12px 30px; border-radius: 50px;
            color: #fff; font-weight: bold; cursor: pointer; font-size: 1rem;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3); transition: 0.2s;
        }
        .btn:hover { transform: scale(1.05); }
        .btn.outline { background: transparent; border: 1px solid #fff; margin-left: 10px; }

        /* å­˜æ¡£åˆ—è¡¨ */
        .slot-list { max-height: 200px; overflow-y: auto; text-align: left; margin-bottom: 15px; }
        .slot {
            padding: 10px; background: rgba(255,255,255,0.05); margin-bottom: 5px;
            border-radius: 6px; cursor: pointer; display: flex; justify-content: space-between;
        }
        .slot:hover { background: rgba(0, 242, 254, 0.1); }

        /* HUD */
        #hud { display: none; pointer-events: none; }
        .hud-top { position: absolute; top: 20px; left: 20px; display: flex; gap: 15px; }
        .stat { background: rgba(0,0,0,0.6); padding: 8px 15px; border-radius: 20px; border: 1px solid #444; }
        
        /* æŠ€èƒ½æ  */
        .skills {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 15px; pointer-events: auto;
        }
        .s-box {
            width: 60px; height: 60px; background: rgba(0,0,0,0.8);
            border: 2px solid #444; border-radius: 10px; position: relative;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        .s-box.active { border-color: var(--gold); box-shadow: 0 0 15px var(--gold); }
        .cd-bar { position: absolute; bottom: 0; left: 0; width: 100%; height: 0%; background: rgba(0,0,0,0.7); transition: height 0.1s linear; }

        .float-txt {
            position: absolute; font-weight: bold; font-size: 1.2rem; pointer-events: none;
            animation: float 1s forwards; text-shadow: 0 2px 2px #000;
        }
        @keyframes float { to { transform: translateY(-50px); opacity: 0; } }

        /* é”™è¯¯æç¤º */
        #global-error {
            position: fixed; top: 0; left: 0; width: 100%; background: red; color: white;
            text-align: center; padding: 10px; z-index: 9999; display: none;
        }
    </style>
</head>
<body>

    <div id="global-error"></div>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div id="p-pass" class="panel">
            <h1>SECURITY CHECK</h1>
            <p>è¾“å…¥å¯†é’¥å¯åŠ¨ç³»ç»Ÿ</p>
            <input type="password" id="inp-pass" placeholder="Password">
            <button class="btn" onclick="UI.checkPass()">ACCESS</button>
        </div>

        <div id="p-login" class="panel">
            <h1>IDENTITY</h1>
            <p>è¾“å…¥ä»£å· (æ‹¼éŸ³é¦–å­—æ¯)</p>
            <input type="text" id="inp-user" placeholder="ä¾‹: LZY">
            <button class="btn" onclick="UI.login()">CONNECT</button>
        </div>

        <div id="p-saves" class="panel">
            <h1>ARCHIVES</h1>
            <div class="slot-list" id="slot-list"></div>
            <button class="btn" onclick="Game.init(0, null)">æ–°æ¸¸æˆ</button>
            <button class="btn outline" onclick="UI.show('p-login')">è¿”å›</button>
        </div>

        <div id="p-win" class="panel">
            <h1 style="color:var(--gold)">VICTORY</h1>
            <p>æµ…æ»©å·²å¾æœï¼Œå‡†å¤‡æ½œå…¥æ·±æ¸Šï¼Ÿ</p>
            <button class="btn" onclick="Game.nextLevel()">è¿›å…¥æ·±æ¸Š</button>
            <button class="btn outline" onclick="Storage.saveQuit()">å­˜æ¡£é€€å‡º</button>
        </div>

        <div id="p-dead" class="panel">
            <h1 style="color:var(--danger)">W.A.S.T.E.D</h1>
            <button class="btn" onclick="Game.retry()">é‡è¯•</button>
            <button class="btn outline" onclick="Storage.loadUI()">è¿”å›</button>
        </div>

        <div id="hud">
            <div class="hud-top">
                <div class="stat" style="color:var(--danger)">â¤ <span id="v-lives">3</span></div>
                <div class="stat" style="color:var(--primary)">ğŸ“ <span id="v-size">0</span></div>
                <div class="stat">âš“ <span id="v-zone">Zone 1</span></div>
            </div>
            <div class="skills">
                <div class="s-box" id="sk-dash"><div>âš¡</div><small>SPACE</small><div class="cd-bar" id="cd-dash"></div></div>
                <div class="s-box" id="sk-shield"><div>ğŸ›¡ï¸</div><small>J</small><div class="cd-bar" id="cd-shield"></div></div>
                <div class="s-box" id="sk-magnet"><div>ğŸ§²</div><small>K</small><div class="cd-bar" id="cd-magnet"></div></div>
                <div class="s-box" id="sk-sonar" style="display:none"><div>ğŸ“¡</div><small>L</small><div class="cd-bar" id="cd-sonar"></div></div>
            </div>
        </div>
    </div>

<script>
/** * ç´§æ€¥é”™è¯¯å¤„ç†ï¼šé˜²æ­¢è„šæœ¬æŠ¥é”™å¯¼è‡´é»‘å±
 */
window.onerror = function(msg, url, line) {
    const el = document.getElementById('global-error');
    el.style.display = 'block';
    el.innerText = "Error: " + msg + " (Line: " + line + ")";
    return false; 
};

/**
 * æ¸¸æˆé…ç½®
 */
const CFG = {
    PASS: 'xjblsy99',
    WORLD: 2500,
    LEVELS: [
        { id:0, name:"é˜³å…‰æµ…æ»©", target:60, startR:15, dark:0, bg:['#006994','#003366'], skills:['dash','shield','magnet'], spawns:['tetra','goldie','ray'] },
        { id:1, name:"æ·±æ¸Šç¦åŒº", target:200, startR:70, dark:0.95, bg:['#050505','#1a0b2e'], skills:['dash','shield','magnet','sonar'], spawns:['goldie','angler','shark','whale'] }
    ],
    FISH: {
        tetra: {r:[5,12], spd:3, col:'#ff00cc', type:'neon'},
        goldie: {r:[12,25], spd:2.2, col:'#ff9f43', type:'gold'},
        ray: {r:[20,35], spd:2.5, col:'#00d2d3', type:'flat'},
        angler: {r:[35,55], spd:1.8, col:'#a55eea', type:'angler'},
        shark: {r:[50,80], spd:4, col:'#7f8fa6', type:'shark', aggro:true},
        whale: {r:[90,150], spd:1.2, col:'#2f3542', type:'whale'}
    },
    SKILLS: {
        dash: {cd:3000, dur:300}, shield: {cd:12000, dur:3000},
        magnet: {cd:15000, dur:4000, r:400}, sonar: {cd:20000, dur:100, r:1000}
    }
};

/**
 * å­˜å‚¨ç³»ç»Ÿ (é˜²å´©æºƒç‰ˆ)
 */
const Storage = {
    user: null,
    mem: {},
    available: false,
    init() {
        try { localStorage.setItem('t','1'); localStorage.removeItem('t'); this.available=true; }
        catch(e) { console.log('Using memory storage'); }
    },
    getSaves() {
        const k = `DSE_${this.user}`;
        const v = this.available ? localStorage.getItem(k) : this.mem[k];
        return v ? JSON.parse(v) : [];
    },
    save(lvl, score) {
        let s = this.getSaves();
        const now = new Date().toLocaleDateString();
        if(Game.saveId) {
            const idx = s.findIndex(x=>x.id===Game.saveId);
            if(idx>=0) { s[idx].level=lvl; s[idx].score=score; s[idx].date=now; }
        } else {
            Game.saveId = Date.now();
            if(s.length>=4) s.shift();
            s.push({id:Game.saveId, level:lvl, score:score, date:now});
        }
        const val = JSON.stringify(s);
        if(this.available) localStorage.setItem(`DSE_${this.user}`, val);
        else this.mem[`DSE_${this.user}`] = val;
    },
    del(id) {
        if(!confirm('åˆ é™¤?')) return;
        let s = this.getSaves().filter(x=>x.id!==id);
        const val = JSON.stringify(s);
        if(this.available) localStorage.setItem(`DSE_${this.user}`, val);
        else this.mem[`DSE_${this.user}`] = val;
        this.loadUI();
    },
    loadUI() {
        UI.show('p-saves');
        const list = document.getElementById('slot-list');
        list.innerHTML = '';
        const s = this.getSaves();
        if(s.length===0) list.innerHTML = '<div style="color:#666">æš‚æ— å­˜æ¡£</div>';
        s.forEach(x => {
            const div = document.createElement('div');
            div.className = 'slot';
            div.innerHTML = `
                <div onclick="Game.init(${x.level}, ${x.id})">
                    <b style="color:var(--primary)">${CFG.LEVELS[x.level].name}</b>
                    <span style="font-size:0.8em; color:#888">Size: ${Math.floor(x.score)}</span>
                </div>
                <div style="color:red; padding:0 10px;" onclick="Storage.del(${x.id})">Ã—</div>
            `;
            list.appendChild(div);
        });
    },
    saveQuit() {
        this.save(Math.min(Game.lvlIdx+1, 1), Game.player.r);
        this.loadUI();
    }
};
Storage.init();

/**
 * æ¸²æŸ“å™¨ï¼šè´Ÿè´£ç»˜åˆ¶é«˜è´¨é‡é±¼ç±»
 */
const Render = {
    fish(ctx, x, y, r, ang, col, type, phase) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(ang);

        // èº«ä½“å…‰æ³½
        const g = ctx.createRadialGradient(0, -r*0.2, r*0.1, 0, 0, r);
        g.addColorStop(0, '#fff'); g.addColorStop(0.3, col); g.addColorStop(1, '#000');

        const swing = Math.sin(phase);

        // å°¾å·´ (Så½¢éª¨éª¼æ¨¡æ‹Ÿ)
        ctx.fillStyle = col;
        ctx.beginPath();
        if(type==='shark') {
            ctx.moveTo(-r*0.8,0);
            ctx.quadraticCurveTo(-r*1.5, swing*r*0.5, -r*2.2, -r*0.8+swing*r*0.8);
            ctx.lineTo(-r*2.2, r*0.8+swing*r*0.8);
            ctx.quadraticCurveTo(-r*1.5, swing*r*0.5, -r*0.8, 0);
        } else if(type==='whale') {
             ctx.moveTo(-r*0.9, 0); ctx.quadraticCurveTo(-r*1.8, 0, -r*2.4, swing*r*0.5); 
             ctx.lineTo(-r*2.4, -swing*r*0.5); ctx.quadraticCurveTo(-r*1.8, 0, -r*0.9, 0);
        } else {
            ctx.moveTo(-r*0.7,0); ctx.lineTo(-r*1.5, -r*0.6+swing*10); ctx.lineTo(-r*1.5, r*0.6+swing*10);
        }
        ctx.fill();

        // ä¾§é³
        const fAng = Math.PI/4 + Math.sin(phase*0.8)*0.3;
        ctx.beginPath(); ctx.ellipse(r*0.2, r*0.6, r*0.35, r*0.15, fAng, 0, Math.PI*2);
        ctx.ellipse(r*0.2, -r*0.6, r*0.35, r*0.15, -fAng, 0, Math.PI*2);
        ctx.fill();

        // èº«ä½“ä¸»ä½“
        ctx.fillStyle = g;
        ctx.beginPath();
        if(type==='shark') ctx.ellipse(0,0, r*1.2, r*0.65, 0, 0, Math.PI*2);
        else ctx.ellipse(0,0, r, r*0.8, 0, 0, Math.PI*2);
        ctx.fill();

        // çœ¼ç›
        const ex = r*0.4, ey = r*0.35, es = r*0.25;
        ctx.fillStyle='#fff'; 
        ctx.beginPath(); ctx.arc(ex, -ey, es, 0, 6.28); ctx.fill();
        ctx.beginPath(); ctx.arc(ex, ey, es, 0, 6.28); ctx.fill();
        ctx.fillStyle='#000';
        ctx.beginPath(); ctx.arc(ex+2, -ey, es*0.5, 0, 6.28); ctx.fill();
        ctx.beginPath(); ctx.arc(ex+2, ey, es*0.5, 0, 6.28); ctx.fill();

        // ç¯ç¬¼é±¼ç¯
        if(type==='angler') {
            ctx.strokeStyle='#888'; ctx.lineWidth=2;
            ctx.beginPath(); ctx.moveTo(r*0.5, -r*0.2); ctx.quadraticCurveTo(r, -r*1.5, r*1.5, -r*1.2); ctx.stroke();
            ctx.fillStyle='#ff0'; ctx.shadowBlur=20; ctx.shadowColor='#ff0';
            ctx.beginPath(); ctx.arc(r*1.5, -r*1.2, 5, 0, 6.28); ctx.fill(); ctx.shadowBlur=0;
        }

        ctx.restore();
    }
};

/**
 * æ¸¸æˆä¸»é€»è¾‘
 */
const Game = {
    cvs: null, ctx: null,
    W: 0, H: 0,
    state: 'STOP',
    loopId: null,
    
    cam: {x:0, y:0},
    player: {x:0, y:0, vx:0, vy:0, r:0, ang:0, tail:0, lives:3, inv:0, skills:{}},
    enemies: [],
    parts: [], // ç²’å­
    keys: {},
    
    lvlIdx: 0,
    saveId: null,
    shake: 0,

    boot() {
        this.cvs = document.getElementById('gameCanvas');
        this.ctx = this.cvs.getContext('2d');
        this.resize();
        window.addEventListener('resize', ()=>this.resize());
        
        window.addEventListener('keydown', e=>{
            this.keys[e.key] = true;
            if(this.state==='PLAY') {
                if(e.code==='Space') this.cast('dash');
                if(e.code==='KeyJ') this.cast('shield');
                if(e.code==='KeyK') this.cast('magnet');
                if(e.code==='KeyL') this.cast('sonar');
            }
            if(e.key==='Enter') UI.enterKey();
        });
        window.addEventListener('keyup', e=>this.keys[e.key]=false);
    },

    resize() {
        this.W = window.innerWidth;
        this.H = window.innerHeight;
        this.cvs.width = this.W;
        this.cvs.height = this.H;
    },

    init(lvl, sid) {
        this.lvlIdx = lvl;
        this.saveId = sid;
        const cfg = CFG.LEVELS[lvl];
        
        this.player.x = CFG.WORLD/2; this.player.y = CFG.WORLD/2;
        this.player.vx = 0; this.player.vy = 0;
        this.player.r = cfg.startR;
        this.player.lives = 3; this.player.inv = 0;
        
        // Reset skills
        ['dash','shield','magnet','sonar'].forEach(k => {
            this.player.skills[k] = {cd:0, active:false};
        });

        this.enemies = [];
        this.parts = [];
        this.state = 'PLAY';
        
        UI.setupHUD(cfg);
        this.loop();
    },

    nextLevel() {
        Storage.save(this.lvlIdx+1, this.player.r);
        this.init(this.lvlIdx+1, this.saveId);
    },
    retry() { this.init(this.lvlIdx, this.saveId); },

    loop() {
        if(this.state !== 'PLAY') return;
        
        this.ctx.clearRect(0,0,this.W,this.H);
        this.update();
        this.draw();
        
        this.loopId = requestAnimationFrame(()=>this.loop());
    },

    update() {
        const p = this.player;
        const lvl = CFG.LEVELS[this.lvlIdx];
        
        // 1. ç©å®¶ç‰©ç†
        let acc = 0.5;
        let max = 8 * (30/(p.r+20));
        if(p.skills.dash.active) max *= 2.5;

        if(this.keys['ArrowUp'] || this.keys['w']) p.vy -= acc;
        if(this.keys['ArrowDown'] || this.keys['s']) p.vy += acc;
        if(this.keys['ArrowLeft'] || this.keys['a']) p.vx -= acc;
        if(this.keys['ArrowRight'] || this.keys['d']) p.vx += acc;

        p.vx *= 0.94; p.vy *= 0.94;
        let spd = Math.sqrt(p.vx**2 + p.vy**2);
        if(spd > max) { p.vx=(p.vx/spd)*max; p.vy=(p.vy/spd)*max; }

        p.x += p.vx; p.y += p.vy;
        
        // è¾¹ç•Œ
        if(p.x<p.r) p.x=p.r; if(p.x>CFG.WORLD-p.r) p.x=CFG.WORLD-p.r;
        if(p.y<p.r) p.y=p.r; if(p.y>CFG.WORLD-p.r) p.y=CFG.WORLD-p.r;

        if(spd>0.1) p.ang = Math.atan2(p.vy, p.vx);
        p.tail += 0.2 + spd*0.05;

        // æ‘„åƒæœº
        this.cam.x += (p.x - this.W/2 - this.cam.x) * 0.1;
        this.cam.y += (p.y - this.H/2 - this.cam.y) * 0.1;

        if(this.shake>0) this.shake *= 0.9;

        // 2. æ•Œäºº
        if(this.enemies.length < 25 && Math.random()<0.03) this.spawn(lvl);

        for(let i=this.enemies.length-1; i>=0; i--) {
            let e = this.enemies[i];
            
            if(e.stun>0) { e.stun--; e.vx*=0.9; e.vy*=0.9; }
            else {
                if(e.aggro && !p.skills.shield.active) {
                    const dx=p.x-e.x, dy=p.y-e.y;
                    const d = Math.sqrt(dx*dx+dy*dy);
                    if(d<800) { e.vx+=(dx/d)*0.25; e.vy+=(dy/d)*0.25; }
                }
                if(p.skills.magnet.active && e.r<p.r) {
                    const dx=p.x-e.x, dy=p.y-e.y;
                    const d = Math.sqrt(dx*dx+dy*dy);
                    if(d<CFG.SKILLS.magnet.r) { e.vx+=(dx/d)*0.8; e.vy+=(dy/d)*0.8; }
                }
                e.x+=e.vx; e.y+=e.vy;
            }

            const es = Math.sqrt(e.vx**2+e.vy**2);
            if(es>0.1) e.ang = Math.atan2(e.vy, e.vx);
            e.tail += 0.15 + es*0.05;

            // è·ç¦»å‰”é™¤
            if(Math.abs(e.x - p.x) > 2000 || Math.abs(e.y - p.y) > 2000) {
                this.enemies.splice(i,1); continue;
            }

            // ç¢°æ’
            const dist = Math.sqrt((p.x-e.x)**2 + (p.y-e.y)**2);
            if(dist < p.r + e.r*0.8) {
                if(p.r > e.r*1.1) {
                    this.enemies.splice(i,1);
                    p.r += e.r * 0.08;
                    this.boom(e.x, e.y, e.color);
                    UI.txt(`+${Math.floor(e.r)}`, e.x, e.y, '#ffd700');
                    UI.stats();
                    if(p.r >= lvl.target) { this.state='PAUSED'; UI.show('p-win'); }
                } else if(e.r > p.r) {
                    if(p.inv<=0 && !p.skills.shield.active) {
                        p.lives--; p.inv=120; this.shake=20;
                        UI.txt("å±é™©!", p.x, p.y-50, '#ff0055');
                        UI.stats();
                        if(p.lives<=0) { this.state='OVER'; UI.show('p-dead'); }
                    }
                }
            }
        }
        if(p.inv>0) p.inv--;

        // 3. ç²’å­
        for(let i=this.parts.length-1; i>=0; i--) {
            let pt = this.parts[i];
            pt.x+=pt.vx; pt.y+=pt.vy; pt.l-=0.03;
            if(pt.l<=0) this.parts.splice(i,1);
        }

        // 4. CD
        for(let k in p.skills) {
            if(p.skills[k].cd > 0) {
                p.skills[k].cd -= 16;
                UI.cd(k, p.skills[k].cd);
            }
        }
    },

    spawn(lvl) {
        const k = lvl.spawns[Math.floor(Math.random()*lvl.spawns.length)];
        const proto = CFG.FISH[k];
        
        let ex, ey;
        // ç”Ÿæˆåœ¨æ‘„åƒæœºå¤–
        if(Math.random()>0.5) {
            ex = this.cam.x + (Math.random()>0.5?-200:this.W+200);
            ey = this.cam.y + Math.random()*this.H;
        } else {
            ex = this.cam.x + Math.random()*this.W;
            ey = this.cam.y + (Math.random()>0.5?-200:this.H+200);
        }
        
        if(ex<0)ex=0; if(ex>CFG.WORLD)ex=CFG.WORLD;
        if(ey<0)ey=0; if(ey>CFG.WORLD)ey=CFG.WORLD;

        let r = proto.r[0] + Math.random()*(proto.r[1]-proto.r[0]);
        if(this.player.r>100 && !proto.aggro && Math.random()<0.3) r*=1.5;

        this.enemies.push({
            x:ex, y:ey, vx:(Math.random()-0.5)*proto.spd, vy:(Math.random()-0.5)*proto.spd,
            r:r, color:proto.col, type:proto.type, aggro:proto.aggro,
            ang:0, tail:0, stun:0
        });
    },

    boom(x, y, c) {
        for(let i=0; i<8; i++) this.parts.push({
            x:x, y:y, vx:(Math.random()-0.5)*10, vy:(Math.random()-0.5)*10,
            r:Math.random()*5, color:c, l:1
        });
    },

    cast(k) {
        if(!CFG.LEVELS[this.lvlIdx].skills.includes(k)) return;
        const s = this.player.skills[k];
        const cfg = CFG.SKILLS[k];
        if(s.cd<=0 && !s.active) {
            s.active=true; s.cd=cfg.cd;
            if(k==='sonar') {
                this.shake=30; this.enemies.forEach(e=>e.stun=180);
                UI.txt("SONAR!", this.player.x, this.player.y-50, '#fff');
            } else {
                UI.txt(k.toUpperCase(), this.player.x, this.player.y-50, cfg.color);
            }
            setTimeout(()=>s.active=false, cfg.dur);
        }
    },

    draw() {
        const ctx = this.ctx;
        const p = this.player;
        const lvl = CFG.LEVELS[this.lvlIdx];

        ctx.save();
        // æ‘„åƒæœº + éœ‡åŠ¨
        ctx.translate(-this.cam.x + (Math.random()-0.5)*this.shake, -this.cam.y + (Math.random()-0.5)*this.shake);

        // èƒŒæ™¯
        const bg = ctx.createLinearGradient(0,0,0,CFG.WORLD);
        bg.addColorStop(0, lvl.bg[0]); bg.addColorStop(1, lvl.bg[1]);
        ctx.fillStyle = bg; ctx.fillRect(0,0,CFG.WORLD, CFG.WORLD);
        
        ctx.strokeStyle = 'rgba(255,255,255,0.1)'; ctx.lineWidth=10;
        ctx.strokeRect(0,0,CFG.WORLD, CFG.WORLD);

        // æ·±æµ·å…‰ç…§
        if(lvl.dark > 0) {
            ctx.fillStyle = `rgba(0,0,0,${lvl.dark})`;
            ctx.fillRect(this.cam.x, this.cam.y, this.W, this.H);
            ctx.globalCompositeOperation = 'destination-out';
            
            this.light(p.x, p.y, p.r*5+250);
            this.enemies.forEach(e=>{ if(e.type==='angler') this.light(e.x, e.y, e.r*4+100); });
            
            ctx.globalCompositeOperation = 'source-over';
        }

        // æŠ€èƒ½
        if(p.skills.shield.active) {
            ctx.strokeStyle='#ffd700'; ctx.lineWidth=4; ctx.setLineDash([10,5]);
            ctx.beginPath(); ctx.arc(p.x, p.y, p.r+20, 0, 6.28); ctx.stroke(); ctx.setLineDash([]);
        }
        if(p.skills.magnet.active) {
            ctx.strokeStyle='rgba(189,0,255,0.3)'; ctx.lineWidth=2;
            ctx.beginPath(); ctx.arc(p.x, p.y, CFG.SKILLS.magnet.r, 0, 6.28); ctx.stroke();
        }
        if(p.skills.sonar.active) {
            ctx.strokeStyle='#fff'; ctx.lineWidth=20;
            ctx.beginPath(); ctx.arc(p.x, p.y, CFG.SKILLS.sonar.r, 0, 6.28); ctx.stroke();
        }

        // å®ä½“
        this.enemies.forEach(e => Render.fish(ctx, e.x, e.y, e.r, e.ang, e.color, e.type, e.tail));
        if(p.inv%10 < 5) Render.fish(ctx, p.x, p.y, p.r, p.ang, '#00f2fe', 'player', p.tail);

        // ç²’å­
        this.parts.forEach(pt => {
            ctx.globalAlpha=pt.l; ctx.fillStyle=pt.color;
            ctx.beginPath(); ctx.arc(pt.x, pt.y, pt.r, 0, 6.28); ctx.fill();
        });
        ctx.globalAlpha=1;

        ctx.restore();
    },

    light(x, y, r) {
        const g = this.ctx.createRadialGradient(x, y, r*0.1, x, y, r);
        g.addColorStop(0, 'rgba(0,0,0,1)'); g.addColorStop(1, 'rgba(0,0,0,0)');
        this.ctx.fillStyle=g; this.ctx.beginPath(); this.ctx.arc(x, y, r, 0, 6.28); this.ctx.fill();
    }
};

/* --- UI ç®¡ç† --- */
const UI = {
    show(id) {
        document.querySelectorAll('.panel').forEach(p => p.style.display = 'none');
        if(id) document.getElementById(id).style.display = 'block';
    },

    enterKey() {
        if(document.getElementById('p-pass').style.display !== 'none') this.checkPass();
        else if(document.getElementById('p-login').style.display !== 'none') this.login();
    },

    checkPass() {
        const v = document.getElementById('inp-pass').value;
        if(v === CFG.PASS) this.show('p-login');
        else alert('å¯†ç é”™è¯¯');
    },

    login() {
        const v = document.getElementById('inp-user').value.toUpperCase().trim();
        if(v && /^[A-Z]+$/.test(v)) {
            Storage.user = v;
            Storage.loadUI();
        } else alert('ä»£å·æ— æ•ˆ (ä»…é™å­—æ¯)');
    },

    setupHUD(lvl) {
        this.show('');
        document.getElementById('hud').style.display = 'block';
        document.getElementById('v-zone').innerText = lvl.name;
        document.getElementById('ui-target').innerText = lvl.target;
        ['dash','shield','magnet','sonar'].forEach(k => {
            document.getElementById(`sk-${k}`).style.display = lvl.skills.includes(k) ? 'flex' : 'none';
        });
        this.stats();
    },

    stats() {
        document.getElementById('v-size').innerText = Math.floor(Game.player.r);
        document.getElementById('v-lives').innerText = Game.player.lives;
    },

    cd(k, val) {
        const max = CFG.SKILLS[k].cd;
        const h = (val/max)*100;
        document.getElementById(`cd-${k}`).style.height = h+'%';
        const el = document.getElementById(`sk-${k}`);
        if(val<=0) el.classList.add('active'); else el.classList.remove('active');
    },

    txt(t, x, y, c) {
        // è½¬æ¢ä¸–ç•Œåæ ‡åˆ°å±å¹•åæ ‡
        const sx = x - Game.cam.x;
        const sy = y - Game.cam.y;
        if(sx<0 || sx>Game.W || sy<0 || sy>Game.H) return;
        
        const d = document.createElement('div');
        d.className = 'float-txt'; d.innerText = t;
        d.style.left = sx+'px'; d.style.top = sy+'px'; d.style.color = c;
        document.getElementById('ui-layer').appendChild(d);
        setTimeout(()=>d.remove(), 800);
    }
};

// å¯åŠ¨
window.onload = function() {
    Game.boot();
    // å¼ºåˆ¶å…ˆæ˜¾ç¤ºå¯†ç æ¡†
    UI.show('p-pass');
};
</script>
</body>
</html>
