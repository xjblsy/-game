<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Deep Sea Evolution: Living World</title>
    <style>
        :root {
            --cyan: #00f2fe;
            --gold: #ffd700;
            --pink: #ff0055;
            --panel-bg: rgba(10, 20, 35, 0.92);
        }

        body {
            margin: 0; padding: 0; background: #000;
            overflow: hidden; font-family: 'Microsoft YaHei', sans-serif;
            width: 100vw; height: 100vh; color: white;
            display: flex; justify-content: center; align-items: center;
        }

        canvas { position: absolute; top: 0; left: 0; z-index: 1; }

        /* UIå±‚çº§ */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 999; pointer-events: none;
        }

        /* æ“ä½œæç¤º (æ–°åŠŸèƒ½) */
        #controls-hint {
            position: absolute; top: 20px; right: 20px;
            background: rgba(0,0,0,0.6); padding: 10px 20px;
            border-radius: 8px; border: 1px solid rgba(255,255,255,0.2);
            font-size: 12px; color: #ccc; pointer-events: none;
            backdrop-filter: blur(4px); text-align: right;
        }
        .key-badge {
            display: inline-block; background: rgba(255,255,255,0.2);
            padding: 2px 6px; border-radius: 4px; color: #fff; font-weight: bold;
            margin: 0 2px; font-family: monospace;
        }

        /* é€šç”¨é¢æ¿ */
        .panel {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: var(--panel-bg);
            border: 1px solid rgba(255,255,255,0.15);
            box-shadow: 0 0 60px rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(15px);
            padding: 40px; border-radius: 16px;
            text-align: center; min-width: 360px;
            pointer-events: auto; display: none;
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        .panel.active { display: block; }
        @keyframes popIn { from { transform: translate(-50%, -40%) scale(0.9); opacity: 0; } to { transform: translate(-50%, -50%) scale(1); opacity: 1; } }

        /* æš‚åœé®ç½© */
        #pause-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.4); backdrop-filter: blur(8px);
            display: none; justify-content: center; align-items: center;
            z-index: 500; pointer-events: auto;
        }
        #pause-overlay.active { display: flex; }

        h1 { margin: 0 0 20px; color: var(--cyan); text-shadow: 0 0 15px var(--cyan); font-size: 26px; letter-spacing: 2px; }
        
        input {
            background: rgba(0,0,0,0.5); border: 1px solid #555;
            color: #fff; padding: 14px; width: 100%; border-radius: 8px;
            font-size: 1.1rem; text-align: center; margin-bottom: 20px; outline: none;
        }
        input:focus { border-color: var(--cyan); }

        .btn {
            background: linear-gradient(135deg, #0061ff, var(--cyan));
            border: none; padding: 12px 35px; border-radius: 30px;
            color: #000; font-weight: bold; cursor: pointer;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3); transition: 0.2s; font-size: 16px;
        }
        .btn:hover { transform: scale(1.05); box-shadow: 0 8px 25px rgba(0,242,254,0.4); }
        .btn.outline { background: transparent; border: 1px solid rgba(255,255,255,0.3); color: #ddd; margin-top: 15px; }
        .btn.outline:hover { border-color: #fff; color: #fff; background: rgba(255,255,255,0.1); }

        /* HUD */
        #hud { display: none; pointer-events: none; }
        .hud-top { position: absolute; top: 20px; left: 20px; display: flex; gap: 15px; }
        .stat { background: rgba(0,0,0,0.7); padding: 8px 16px; border-radius: 20px; border: 1px solid rgba(255,255,255,0.1); font-weight: bold; font-size: 14px; display: flex; align-items: center; gap: 6px; }
        
        .skill-bar { position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); display: flex; gap: 15px; pointer-events: auto; }
        .sk-box {
            width: 64px; height: 64px; background: rgba(10,20,30,0.9);
            border: 2px solid #444; border-radius: 12px; position: relative;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        .sk-box.active { border-color: var(--gold); box-shadow: 0 0 20px rgba(255,215,0,0.3); }
        .sk-icon { font-size: 1.5rem; z-index: 2; }
        .sk-key { font-size: 0.7rem; color: #888; margin-top: 3px; z-index: 2; font-weight: bold; }
        .sk-cd { position: absolute; bottom: 0; left: 0; width: 100%; height: 0%; background: rgba(0,0,0,0.8); z-index: 1; transition: height 0.1s linear; }

        .float-txt {
            position: absolute; font-weight: 900; font-size: 20px; pointer-events: none;
            text-shadow: 0 2px 4px #000; animation: float 0.8s forwards;
        }
        @keyframes float { to { transform: translateY(-50px); opacity: 0; } }

        #err-log { position: fixed; top: 0; left: 0; width: 100%; background: #d00; color: #fff; text-align: center; display: none; z-index: 10000; }
        
        /* å­˜æ¡£åˆ—è¡¨ */
        .slot-list { margin: 15px 0; max-height: 200px; overflow-y: auto; }
        .slot {
            background: rgba(255,255,255,0.05); padding: 12px; margin-bottom: 8px;
            border-radius: 8px; display: flex; justify-content: space-between;
            cursor: pointer; border: 1px solid transparent;
        }
        .slot:hover { border-color: var(--cyan); background: rgba(0,242,254,0.1); }
    </style>
</head>
<body>

    <div id="err-log"></div>
    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div id="controls-hint" style="display: none;">
            <div><span class="key-badge">P</span> æš‚åœæ¸¸æˆ</div>
            <div style="margin-top:5px;"><span class="key-badge">ESC</span> é€€å‡º/èœå•</div>
        </div>

        <div id="p-pass" class="panel active">
            <h1>SYSTEM LOCKED</h1>
            <p>è¯·è¾“å…¥å¯†é’¥å¯åŠ¨ç³»ç»Ÿ</p>
            <input type="password" id="inp-pass" placeholder="Password">
            <button class="btn" onclick="App.verifyPass()">ACCESS</button>
        </div>

        <div id="p-login" class="panel">
            <h1>IDENTITY</h1>
            <p>è¾“å…¥ä»£å· (æ‹¼éŸ³é¦–å­—æ¯)</p>
            <input type="text" id="inp-user" maxlength="8" placeholder="ä¾‹: LZY">
            <button class="btn" onclick="App.login()">CONNECT</button>
            <br>
            <button class="btn outline" onclick="App.clearData()">âš  æ¸…é™¤ç¼“å­˜æ•°æ®</button>
        </div>

        <div id="p-saves" class="panel">
            <h1>ARCHIVES</h1>
            <div class="slot-list" id="slot-list"></div>
            <button class="btn" onclick="App.newGame()">å¼€å§‹æ–°å¾ç¨‹</button>
            <br>
            <button class="btn outline" onclick="UI.show('p-login')">é€€å‡º</button>
        </div>

        <div id="p-win" class="panel">
            <h1 style="color:var(--gold)">VICTORY</h1>
            <p>æµ·åŸŸå·²å¾æœ</p>
            <div style="text-align: left; background: rgba(255,255,255,0.05); padding: 15px; border-radius: 8px; margin: 15px 0;">
                <p style="margin:0; color:#fff">ä¸‹ä¸€ç«™: <b style="color:var(--pink)">æ·±æ¸Šç¦åŒº</b></p>
                <small style="color:#888">ç¯å¢ƒ: æåº¦é»‘æš— | å¨èƒ: å·¨å‹ç”Ÿç‰©</small>
            </div>
            <button class="btn" onclick="Game.nextLevel()">æ½œå…¥æ·±æ¸Š</button>
            <br>
            <button class="btn outline" onclick="App.saveQuit()">å­˜æ¡£é€€å‡º</button>
        </div>

        <div id="p-dead" class="panel">
            <h1 style="color:var(--pink)">FAILURE</h1>
            <p>ç”Ÿå‘½è€—å°½</p>
            <button class="btn" onclick="Game.retry()">é‡è¯•</button>
            <br>
            <button class="btn outline" onclick="App.loadSaves()">è¿”å›</button>
        </div>

        <div id="pause-overlay">
            <div class="panel active" style="background:rgba(0,0,0,0.8);">
                <h1 style="color: #fff;">PAUSED</h1>
                <button class="btn" onclick="Game.togglePause()">ç»§ç»­æ¸¸æˆ</button>
                <br>
                <button class="btn outline" onclick="App.saveQuit()">ä¿å­˜å¹¶é€€å‡º</button>
            </div>
        </div>

        <div id="hud">
            <div class="hud-top">
                <div class="stat" style="border-left:3px solid var(--pink); color:var(--pink)">â¤ <span id="v-lives">3</span></div>
                <div class="stat" style="border-left:3px solid var(--cyan); color:var(--cyan)">ğŸ“ <span id="v-size">0</span></div>
                <div class="stat">âš“ <span id="v-zone">Zone</span></div>
            </div>
            <div class="skill-bar">
                <div class="sk-box" id="s-dash"><div class="sk-icon">âš¡</div><div class="sk-key">SPACE</div><div class="sk-cd" id="c-dash"></div></div>
                <div class="sk-box" id="s-shield"><div class="sk-icon">ğŸ›¡ï¸</div><div class="sk-key">J</div><div class="sk-cd" id="c-shield"></div></div>
                <div class="sk-box" id="s-magnet"><div class="sk-icon">ğŸ§²</div><div class="sk-key">K</div><div class="sk-cd" id="c-magnet"></div></div>
                <div class="sk-box" id="s-sonar" style="display:none"><div class="sk-icon">ğŸ“¡</div><div class="sk-key">L</div><div class="sk-cd" id="c-sonar"></div></div>
            </div>
        </div>
    </div>

<script>
/* --- 0. ç´§æ€¥é”™è¯¯å¤„ç† --- */
window.onerror = function(msg, url, line) {
    document.getElementById('err-log').style.display = 'block';
    document.getElementById('err-log').innerText = `Err: ${msg} (L${line})`;
    return false;
};

/* --- 1. é…ç½® --- */
const CFG = {
    PASS: 'xjblsy99',
    WORLD: 3000, // åœ°å›¾é«˜åº¦
    WIDTH: 2000, // åœ°å›¾å®½åº¦
    LEVELS: [
        { 
            id:0, name:"é˜³å…‰æµ…æ»©", target:60, startR:15, dark:0, 
            skyColor: ['#4facfe', '#00f2fe'], // è“å¤©
            waterColor: ['#00f2fe', '#006994'], 
            skills:['dash','shield','magnet'], 
            spawns:['clownfish','seahorse','tetra'] 
        },
        { 
            id:1, name:"æ·±æ¸Šç¦åŒº", target:200, startR:70, dark:0.96, 
            skyColor: ['#000000', '#050510'], 
            waterColor: ['#050510', '#1a0b2e'], 
            skills:['dash','shield','magnet','sonar'], 
            spawns:['angler','shark','whale'] 
        }
    ],
    FISH: {
        // æ›¿æ¢äº†åŸæ¥çš„æŠ½è±¡é±¼ï¼Œæ”¹ä¸ºå…·ä½“ç§ç±»
        clownfish: { r:[12,20], spd:2.5, color:'#ff9f43', type:'clownfish' }, // å°ä¸‘é±¼
        seahorse:  { r:[18,30], spd:2.0, color:'#feca57', type:'seahorse' },  // æµ·é©¬
        tetra:     { r:[6,12],  spd:3.5, color:'#ff00cc', type:'neon' },      // éœ“è™¹é±¼(ä¿ç•™ä½œä¸ºé¥²æ–™)
        angler:    { r:[40,60], spd:1.8, color:'#a55eea', type:'angler' },    // ç¯ç¬¼é±¼
        shark:     { r:[60,90], spd:4.5, color:'#7f8fa6', type:'shark', aggro:true },
        whale:     { r:[100,180],spd:1.2,color:'#2f3542', type:'whale' }
    },
    SKILLS: {
        dash: {cd:3000, dur:300}, shield: {cd:12000, dur:3000},
        magnet: {cd:15000, dur:4000, r:450}, sonar: {cd:20000, dur:150, r:1200}
    }
};

/* --- 2. å­˜å‚¨ç³»ç»Ÿ --- */
const Store = {
    mem: {}, ok: false,
    init() { try { localStorage.setItem('t','1'); localStorage.removeItem('t'); this.ok=true; } catch(e){} },
    get(k) { return this.ok ? localStorage.getItem(k) : this.mem[k]; },
    set(k,v) { if(this.ok) localStorage.setItem(k,v); else this.mem[k]=v; },
    clear() { if(this.ok) localStorage.clear(); }
};
Store.init();

/* --- 3. æ¸²æŸ“å¼•æ“ (å»ºæ¨¡ä¼˜åŒ–) --- */
const Render = {
    // ç»˜åˆ¶èƒŒæ™¯ç¯å¢ƒ (å¤©ç©ºã€æµ·æ°´ã€æµ·åº•)
    environment(ctx, camY, width, height, lvl) {
        // 1. å¤©ç©ºå±‚ (åªæœ‰åœ¨åœ°å›¾é¡¶éƒ¨èƒ½çœ‹åˆ°)
        if(camY < 0) {
            const skyH = Math.abs(camY) + 100;
            const skyG = ctx.createLinearGradient(0, camY, 0, 0);
            skyG.addColorStop(0, lvl.skyColor[0]);
            skyG.addColorStop(1, lvl.skyColor[1]);
            ctx.fillStyle = skyG;
            ctx.fillRect(0, camY, width, Math.max(skyH, 0));
        }

        // 2. æµ·æ°´å±‚ (ä¸»ä½“)
        const seaG = ctx.createLinearGradient(0, 0, 0, CFG.WORLD);
        seaG.addColorStop(0, lvl.waterColor[0]);
        seaG.addColorStop(1, lvl.waterColor[1]);
        ctx.fillStyle = seaG;
        ctx.fillRect(0, 0, CFG.WIDTH, CFG.WORLD);

        // 3. æµ·åº•åœ°å½¢ (åº•éƒ¨è£…é¥°)
        const floorY = CFG.WORLD;
        ctx.fillStyle = lvl.id === 0 ? '#e1b12c' : '#2d3436'; // æ²™åœ° vs å²©çŸ³
        ctx.beginPath();
        ctx.moveTo(0, floorY);
        // ç®€å•çš„èµ·ä¼åœ°å½¢ç”Ÿæˆ
        for(let x=0; x<=CFG.WIDTH; x+=100) {
            // åŸºäºå›ºå®šç§å­ç”Ÿæˆä¼ªéšæœºåœ°å½¢ï¼Œä¿è¯ä¸é—ªçƒ
            const offset = Math.sin(x * 0.01) * 50 + Math.cos(x * 0.05) * 30;
            ctx.lineTo(x, floorY + offset);
        }
        ctx.lineTo(CFG.WIDTH, floorY + 200);
        ctx.lineTo(0, floorY + 200);
        ctx.fill();

        // 4. æµ·åº•è£…é¥° (çŠç‘š/å²©çŸ³)
        Game.decor.forEach(d => {
            if(d.y > floorY - 100) {
                ctx.save();
                ctx.translate(d.x, d.y);
                ctx.fillStyle = d.c;
                ctx.beginPath();
                ctx.arc(0, 0, d.r, Math.PI, 0); // åŠåœ†çŠç‘š
                ctx.fill();
                ctx.restore();
            }
        });
    },

    fish(ctx, x, y, r, ang, color, type, phase) {
        const safeColor = color || '#fff'; 
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(ang);

        const swing = Math.sin(phase);

        // --- é±¼ç±»å»ºæ¨¡åˆ†æ”¯ ---
        if (type === 'clownfish') {
            // å°ä¸‘é±¼ï¼šæ©™èº« + ç™½æ¡çº¹
            ctx.fillStyle = '#e67e22'; // æ©™è‰²
            // èº«ä½“
            ctx.beginPath(); ctx.ellipse(0, 0, r, r*0.6, 0, 0, Math.PI*2); ctx.fill();
            // å°¾å·´
            ctx.beginPath(); ctx.moveTo(-r*0.8,0); ctx.lineTo(-r*1.5, -r*0.6+swing*5); ctx.lineTo(-r*1.5, r*0.6+swing*5); ctx.fill();
            // ç™½æ¡çº¹
            ctx.fillStyle = '#fff';
            ctx.globalCompositeOperation = 'source-atop'; // é™åˆ¶åœ¨èº«ä½“å†…
            ctx.fillRect(-r*0.5, -r, r*0.3, r*2);
            ctx.fillRect(0, -r, r*0.3, r*2);
            ctx.fillRect(r*0.5, -r, r*0.3, r*2);
            ctx.globalCompositeOperation = 'source-over';
            // çœ¼ç›
            ctx.fillStyle='#000'; ctx.beginPath(); ctx.arc(r*0.6, -r*0.2, r*0.15, 0, 6.28); ctx.fill();

        } else if (type === 'seahorse') {
            // æµ·é©¬ï¼šç‰¹æ®Šçš„ç›´ç«‹å§¿æ€ (åœ¨é¡¶è§†å›¾ä¸­è¡¨ç°ä¸ºå·æ›²)
            ctx.fillStyle = safeColor;
            // å¤´éƒ¨ (é•¿å»)
            ctx.beginPath(); ctx.ellipse(r*0.5, -r*0.5, r*0.4, r*0.2, 0.5, 0, 6.28); ctx.fill();
            // èº«ä½“
            ctx.beginPath(); ctx.ellipse(0, 0, r*0.5, r*0.7, 0, 0, 6.28); ctx.fill();
            // å·å°¾
            ctx.beginPath(); 
            ctx.arc(0, r*0.8, r*0.3, 0, Math.PI+swing*0.5); 
            ctx.lineWidth = r*0.3; ctx.strokeStyle = safeColor; ctx.stroke();
            // èƒŒé³ (å¿«é€Ÿæ‘†åŠ¨)
            const fin = Math.sin(phase*5)*r*0.2;
            ctx.fillStyle = '#f1c40f';
            ctx.beginPath(); ctx.arc(-r*0.4, 0, r*0.3+fin, 1.5, 4.7); ctx.fill();

        } else if (type === 'shark') {
            // é²¨é±¼ (éœ¸æ°”)
            const g = ctx.createRadialGradient(0,-r*0.3,r*0.1,0,0,r);
            g.addColorStop(0,'#bdc3c7'); g.addColorStop(0.5,safeColor); g.addColorStop(1,'#2c3e50');
            ctx.fillStyle = g;
            // å°¾å·´
            ctx.beginPath(); ctx.moveTo(-r*0.8,0); 
            ctx.quadraticCurveTo(-r*1.6, swing*r*0.5, -r*2.4, -r*0.9+swing*r);
            ctx.lineTo(-r*2.4, r*0.9+swing*r); ctx.quadraticCurveTo(-r*1.6, swing*r*0.5, -r*0.8, 0); ctx.fill();
            // èº«ä½“
            ctx.beginPath(); ctx.ellipse(0,0, r*1.3, r*0.65, 0, 0, 6.28); ctx.fill();
            // èƒŒé³
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(-r*0.5, -r*1.2); ctx.lineTo(r*0.2, 0); ctx.fill();

        } else {
            // é€šç”¨é±¼ç±» (Neon, Angler, Whale etc)
            const g = ctx.createRadialGradient(0,-r*0.3,r*0.1,0,0,r);
            g.addColorStop(0,'#fff'); g.addColorStop(0.4,safeColor); g.addColorStop(1,'#000');
            
            ctx.fillStyle = safeColor;
            // å°¾å·´
            ctx.beginPath(); ctx.moveTo(-r*0.7,0); ctx.lineTo(-r*1.5, -r*0.6+swing*8); ctx.lineTo(-r*1.5, r*0.6+swing*8); ctx.fill();
            
            // ä¾§é³
            const finAng = 0.6 + Math.sin(phase*0.8)*0.3;
            ctx.beginPath(); ctx.ellipse(r*0.2, r*0.6, r*0.3, r*0.15, finAng, 0, 6.28);
            ctx.ellipse(r*0.2, -r*0.6, r*0.3, r*0.15, -finAng, 0, 6.28); ctx.fill();

            ctx.fillStyle = g;
            ctx.beginPath(); ctx.ellipse(0,0, r, r*0.75, 0, 0, 6.28); ctx.fill();

            // ç¯ç¬¼é±¼ç¯
            if(type === 'angler') {
                ctx.strokeStyle='#888'; ctx.lineWidth=2;
                ctx.beginPath(); ctx.moveTo(r*0.5, -r*0.2); ctx.quadraticCurveTo(r, -r*1.5, r*1.5, -r*1.2); ctx.stroke();
                ctx.fillStyle='#ff0'; ctx.shadowBlur=20; ctx.shadowColor='#ff0';
                ctx.beginPath(); ctx.arc(r*1.5, -r*1.2, 5, 0, 6.28); ctx.fill(); ctx.shadowBlur=0;
            }
        }

        ctx.restore();
    },

    light(ctx, x, y, r) {
        const g = ctx.createRadialGradient(x, y, r*0.1, x, y, r);
        g.addColorStop(0, 'rgba(0,0,0,1)'); g.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle=g; ctx.beginPath(); ctx.arc(x, y, r, 0, 6.28); ctx.fill();
    }
};

/* --- 4. æ¸¸æˆå¼•æ“ --- */
const Game = {
    cvs: null, ctx: null, W: 0, H: 0,
    state: 'STOP', loopId: null, paused: false,
    cam: {x:0, y:0},
    p: { x:0, y:0, vx:0, vy:0, r:0, angle:0, tail:0, lives:3, inv:0, skills:{}, color:'#00f2fe' },
    enemies: [], parts: [], decor: [], 
    keys: {}, lvlIdx: 0, saveId: null, shake: 0,

    init() {
        this.cvs = document.getElementById('gameCanvas');
        this.ctx = this.cvs.getContext('2d');
        this.resize();
        window.addEventListener('resize', ()=>this.resize());
        
        // åˆå§‹åŒ–è£…é¥°ç‰© (çŠç‘š/çŸ³å¤´)
        for(let i=0; i<30; i++) {
            this.decor.push({
                x: Math.random() * CFG.WIDTH,
                y: CFG.WORLD + Math.random() * 150, // åœ¨åº•éƒ¨
                r: 20 + Math.random() * 40,
                c: Math.random()>0.5 ? '#ff7675' : '#55efc4' // çŠç‘šè‰²
            });
        }

        window.addEventListener('keydown', e => {
            if(this.state==='PLAY') {
                // æš‚åœé€»è¾‘
                if(e.code === 'KeyP') this.togglePause();
                if(e.code === 'Escape') {
                    if(this.paused) App.saveQuit();
                    else this.togglePause();
                }
                if(!this.paused) {
                    this.keys[e.key] = true;
                    if(e.code==='Space') this.cast('dash');
                    if(e.code==='KeyJ') this.cast('shield');
                    if(e.code==='KeyK') this.cast('magnet');
                    if(e.code==='KeyL') this.cast('sonar');
                }
            } else if(e.key==='Enter') UI.enter();
        });
        window.addEventListener('keyup', e => this.keys[e.key] = false);
    },

    resize() {
        this.W = window.innerWidth; this.H = window.innerHeight;
        this.cvs.width = this.W; this.cvs.height = this.H;
    },

    togglePause() {
        this.paused = !this.paused;
        const ol = document.getElementById('pause-overlay');
        if(this.paused) ol.classList.add('active');
        else ol.classList.remove('active');
    },

    start(lvl, sid) {
        this.lvlIdx = lvl; this.saveId = sid;
        const cfg = CFG.LEVELS[lvl];

        this.p.x = CFG.WIDTH/2; this.p.y = CFG.WORLD/2; // åˆå§‹ä½ç½®
        this.p.vx = 0; this.p.vy = 0;
        this.p.r = cfg.startR; this.p.lives = 3; this.p.inv = 0;
        this.p.color = '#00f2fe';
        
        this.cam.x = this.p.x - this.W/2;
        this.cam.y = this.p.y - this.H/2;

        ['dash','shield','magnet','sonar'].forEach(k => this.p.skills[k] = {cd:0, active:false});
        this.enemies = []; this.paused = false;
        document.getElementById('pause-overlay').classList.remove('active');
        this.state = 'PLAY';
        
        UI.setupHUD(cfg);
        this.loop();
    },

    nextLevel() { App.save(this.lvlIdx+1, this.p.r); this.start(this.lvlIdx+1, this.saveId); },
    retry() { this.start(this.lvlIdx, this.saveId); },

    loop() {
        if(this.state !== 'PLAY') return;
        
        if(!this.paused) this.update(); // æš‚åœæ—¶ä¸æ›´æ–°é€»è¾‘
        this.draw(); // æš‚åœæ—¶ç»§ç»­ç»˜åˆ¶(ä¿æŒç”»é¢)
        
        this.loopId = requestAnimationFrame(()=>this.loop());
    },

    update() {
        const p = this.p;
        const lvl = CFG.LEVELS[this.lvlIdx];

        // 1. ç§»åŠ¨
        let acc = 0.5;
        let max = 8 * (30/(p.r+20));
        if(p.skills.dash.active) max *= 2.5;

        if(this.keys['ArrowUp']||this.keys['w']) p.vy -= acc;
        if(this.keys['ArrowDown']||this.keys['s']) p.vy += acc;
        if(this.keys['ArrowLeft']||this.keys['a']) p.vx -= acc;
        if(this.keys['ArrowRight']||this.keys['d']) p.vx += acc;

        p.vx *= 0.94; p.vy *= 0.94;
        let spd = Math.sqrt(p.vx**2 + p.vy**2);
        if(spd > max) { p.vx=(p.vx/spd)*max; p.vy=(p.vy/spd)*max; }

        p.x += p.vx; p.y += p.vy;
        
        // è¾¹ç•Œ (åŒ…å«å¤©ç©ºå’Œæµ·åº•ç¼“å†²)
        if(p.x<p.r) p.x=p.r; if(p.x>CFG.WIDTH-p.r) p.x=CFG.WIDTH-p.r;
        if(p.y<-200) p.y=-200; if(p.y>CFG.WORLD+200) p.y=CFG.WORLD+200; // å…è®¸ç¨å¾®æ¸¸å‡ºè¾¹ç•Œçœ‹é£æ™¯

        if(spd > 0.1) p.angle = Math.atan2(p.vy, p.vx);
        p.tail += 0.2 + spd*0.05;

        // æ‘„åƒæœºè·Ÿéš
        this.cam.x += (p.x - this.W/2 - this.cam.x) * 0.1;
        this.cam.y += (p.y - this.H/2 - this.cam.y) * 0.1;
        if(this.shake > 0) this.shake *= 0.9;

        // ç”Ÿæˆ
        if(this.enemies.length < 25 && Math.random()<0.03) this.spawn(lvl);

        // æ•Œäºº
        for(let i=this.enemies.length-1; i>=0; i--) {
            let e = this.enemies[i];
            if(!e.color) e.color='#fff'; // ä¿é™©

            if(e.stun > 0) { e.stun--; e.vx *= 0.9; e.vy *= 0.9; }
            else {
                if(e.aggro && !p.skills.shield.active) {
                    let dx = p.x-e.x, dy = p.y-e.y;
                    let d = Math.sqrt(dx*dx+dy*dy);
                    if(d < 700) { e.vx += (dx/d)*0.25; e.vy += (dy/d)*0.25; }
                }
                if(p.skills.magnet.active && e.r < p.r) {
                    let dx = p.x-e.x, dy = p.y-e.y;
                    let d = Math.sqrt(dx*dx+dy*dy);
                    if(d < CFG.SKILLS.magnet.r) { e.vx += (dx/d)*0.8; e.vy += (dy/d)*0.8; }
                }
                e.x += e.vx; e.y += e.vy;
            }

            let es = Math.sqrt(e.vx**2 + e.vy**2);
            if(es > 0.1) e.angle = Math.atan2(e.vy, e.vx);
            e.tail += 0.15 + es*0.05;

            if(Math.abs(e.x - p.x) > 2000 || Math.abs(e.y - p.y) > 2000) {
                this.enemies.splice(i,1); continue;
            }

            let dist = Math.sqrt((p.x-e.x)**2 + (p.y-e.y)**2);
            if(dist < p.r + e.r*0.8) {
                if(p.r > e.r*1.1) {
                    this.enemies.splice(i,1);
                    p.r += e.r * 0.08;
                    this.boom(e.x, e.y, e.color);
                    UI.floatText(`+${Math.floor(e.r)}`, e.x - this.cam.x, e.y - this.cam.y, '#ffd700');
                    UI.updateHUD();
                    if(p.r >= lvl.target) { this.state='PAUSED'; UI.show('p-win'); }
                } else if(e.r > p.r) {
                    if(p.inv <= 0 && !p.skills.shield.active) {
                        p.lives--; p.inv=120; this.shake=25;
                        UI.floatText("WARNING", p.x - this.cam.x, p.y-50 - this.cam.y, '#ff0055');
                        UI.updateHUD();
                        if(p.lives <= 0) { this.state='OVER'; UI.show('p-dead'); }
                    }
                }
            }
        }
        if(p.inv > 0) p.inv--;

        // ç²’å­
        for(let i=this.parts.length-1; i>=0; i--) {
            let pt = this.parts[i];
            pt.x += pt.vx; pt.y += pt.vy; pt.l -= 0.03;
            if(pt.l <= 0) this.parts.splice(i,1);
        }

        // CD
        for(let k in p.skills) {
            if(p.skills[k].cd > 0) { p.skills[k].cd -= 16; UI.cd(k, p.skills[k].cd); }
        }
    },

    spawn(lvl) {
        const k = lvl.spawns[Math.floor(Math.random()*lvl.spawns.length)];
        const proto = CFG.FISH[k];
        
        let ex, ey;
        if(Math.random()>0.5) {
            ex = this.cam.x + (Math.random()>0.5 ? -200 : this.W+200);
            ey = this.cam.y + Math.random()*this.H;
        } else {
            ex = this.cam.x + Math.random()*this.W;
            ey = this.cam.y + (Math.random()>0.5 ? -200 : this.H+200);
        }
        
        // å¼ºåˆ¶åœ¨ä¸–ç•ŒèŒƒå›´å†…
        if(ex<0)ex=0; if(ex>CFG.WIDTH)ex=CFG.WIDTH;
        if(ey<0)ey=0; if(ey>CFG.WORLD)ey=CFG.WORLD;

        let r = proto.r[0] + Math.random()*(proto.r[1]-proto.r[0]);
        if(this.p.r > 100 && !proto.aggro && Math.random()<0.4) r *= 1.5;

        this.enemies.push({
            x:ex, y:ey, vx:(Math.random()-0.5)*proto.spd, vy:(Math.random()-0.5)*proto.spd,
            r:r, color:proto.color, type:proto.type, aggro:proto.aggro,
            angle:0, tail:0, stun:0
        });
    },

    boom(x, y, c) {
        for(let i=0; i<8; i++) this.parts.push({
            x:x, y:y, vx:(Math.random()-0.5)*12, vy:(Math.random()-0.5)*12,
            r:Math.random()*5+2, color:c, l:1
        });
    },

    cast(k) {
        if(!CFG.LEVELS[this.lvlIdx].skills.includes(k)) return;
        const s = this.p.skills[k];
        const cfg = CFG.SKILLS[k];
        if(s.cd <= 0 && !s.active) {
            s.active = true; s.cd = cfg.cd;
            if(k==='sonar') {
                this.shake = 40; this.enemies.forEach(e => e.stun = 180);
                UI.floatText("SONAR!", this.p.x - this.cam.x, this.p.y-50 - this.cam.y, '#fff');
            } else {
                UI.floatText(k.toUpperCase(), this.p.x - this.cam.x, this.p.y-50 - this.cam.y, '#fff');
            }
            setTimeout(() => s.active = false, cfg.dur);
        }
    },

    draw() {
        const ctx = this.ctx;
        const p = this.p;
        const lvl = CFG.LEVELS[this.lvlIdx];

        ctx.save();
        let sx = (Math.random()-0.5) * this.shake;
        let sy = (Math.random()-0.5) * this.shake;
        ctx.translate(-this.cam.x + sx, -this.cam.y + sy);

        // 1. ç»˜åˆ¶ç¯å¢ƒèƒŒæ™¯ (å¤©ç©ºã€æµ·æ´‹ã€æµ·åº•)
        Render.environment(ctx, this.cam.y, this.W, this.H, lvl);

        // 2. ç»˜åˆ¶ä¸–ç•Œè¾¹ç•Œæ¡† (è¾…åŠ©)
        ctx.strokeStyle = 'rgba(255,255,255,0.1)'; ctx.lineWidth=10;
        ctx.strokeRect(0,0,CFG.WIDTH, CFG.WORLD);

        // 3. æ·±æµ·å…‰ç…§å±‚
        if(lvl.dark > 0) {
            ctx.fillStyle = `rgba(0,0,0,${lvl.dark})`;
            ctx.fillRect(this.cam.x-50, this.cam.y-50, this.W+100, this.H+100);
            ctx.globalCompositeOperation = 'destination-out';
            Render.light(ctx, p.x, p.y, p.r*5+300);
            this.enemies.forEach(e => { if(e.type==='angler') Render.light(ctx, e.x, e.y, e.r*4+100); });
            ctx.globalCompositeOperation = 'source-over';
        }

        // 4. æŠ€èƒ½
        if(p.skills.shield.active) {
            ctx.strokeStyle='#ffd700'; ctx.lineWidth=4; ctx.setLineDash([15,10]);
            ctx.beginPath(); ctx.arc(p.x, p.y, p.r+30, 0, 6.28); ctx.stroke(); ctx.setLineDash([]);
        }
        if(p.skills.magnet.active) {
            ctx.strokeStyle='rgba(189,0,255,0.2)'; ctx.lineWidth=2;
            ctx.beginPath(); ctx.arc(p.x, p.y, CFG.SKILLS.magnet.r, 0, 6.28); ctx.stroke();
        }
        if(p.skills.sonar.active) {
            ctx.strokeStyle='rgba(255,255,255,0.5)'; ctx.lineWidth=20;
            ctx.beginPath(); ctx.arc(p.x, p.y, CFG.SKILLS.sonar.r, 0, 6.28); ctx.stroke();
        }

        // 5. å®ä½“
        this.enemies.forEach(e => Render.fish(ctx, e.x, e.y, e.r, e.angle, e.color, e.type, e.tail));
        if(p.inv%10 < 5) Render.fish(ctx, p.x, p.y, p.r, p.angle, p.color, 'player', p.tail);

        // 6. ç²’å­
        this.parts.forEach(pt => {
            ctx.globalAlpha = pt.l; ctx.fillStyle = pt.color;
            ctx.beginPath(); ctx.arc(pt.x, pt.y, pt.r, 0, 6.28); ctx.fill();
        });
        ctx.globalAlpha = 1;

        ctx.restore();
    }
};

/* --- 5. App Logic --- */
const App = {
    user: null,
    verifyPass() {
        if(document.getElementById('inp-pass').value === CFG.PASS) UI.show('p-login');
        else alert('å¯†ç æ— æ•ˆ');
    },
    login() {
        const v = document.getElementById('inp-user').value.trim().toUpperCase();
        if(v && /^[A-Z]+$/.test(v)) { this.user = v; this.loadSaves(); }
        else alert('ä»£å·æ— æ•ˆ');
    },
    clearData() {
        if(confirm("æ¸…é™¤ç¼“å­˜?")) { Store.clear(); location.reload(); }
    },
    loadSaves() {
        UI.show('p-saves');
        const list = document.getElementById('slot-list');
        list.innerHTML = '';
        const s = Store.get(`DSE_${this.user}`) ? JSON.parse(Store.get(`DSE_${this.user}`)) : [];
        if(s.length===0) list.innerHTML = '<div style="color:#888">æš‚æ— æ•°æ®</div>';
        s.forEach(x => {
            const d = document.createElement('div');
            d.className = 'slot';
            d.innerHTML = `
                <div onclick="Game.start(${x.lvl}, ${x.id})">
                    <b style="color:var(--gold)">${CFG.LEVELS[x.lvl].name}</b>
                    <span style="font-size:12px;color:#aaa">Size: ${Math.floor(x.score)}</span>
                </div>
                <div style="color:red;padding:0 10px" onclick="App.del(${x.id})">Ã—</div>
            `;
            list.appendChild(d);
        });
    },
    newGame() { Game.start(0, null); },
    save(lvl, score) {
        let s = Store.get(`DSE_${this.user}`) ? JSON.parse(Store.get(`DSE_${this.user}`)) : [];
        if(Game.saveId) {
            let i = s.findIndex(x=>x.id===Game.saveId);
            if(i>=0) { s[i].lvl=lvl; s[i].score=score; }
        } else {
            Game.saveId = Date.now();
            if(s.length>=4) s.shift();
            s.push({id:Game.saveId, lvl:lvl, score:score});
        }
        Store.set(`DSE_${this.user}`, JSON.stringify(s));
    },
    del(id) {
        if(!confirm('åˆ é™¤?'))return;
        let s = JSON.parse(Store.get(`DSE_${this.user}`));
        s = s.filter(x=>x.id!==id);
        Store.set(`DSE_${this.user}`, JSON.stringify(s));
        this.loadSaves();
    },
    saveQuit() {
        this.save(Math.min(Game.lvlIdx+1, 1), Game.p.r);
        this.loadSaves();
    }
};

/* --- 6. UI Utils --- */
const UI = {
    show(id) {
        document.querySelectorAll('.panel').forEach(p => p.classList.remove('active'));
        if(id) document.getElementById(id).classList.add('active');
    },
    enter() {
        if(document.getElementById('p-pass').classList.contains('active')) App.verifyPass();
        else if(document.getElementById('p-login').classList.contains('active')) App.login();
    },
    setupHUD(lvl) {
        this.show(''); 
        document.getElementById('hud').style.display = 'block';
        document.getElementById('controls-hint').style.display = 'block';
        document.getElementById('v-zone').innerText = lvl.name;
        ['dash','shield','magnet','sonar'].forEach(k => {
            document.getElementById(`s-${k}`).style.display = lvl.skills.includes(k) ? 'flex' : 'none';
        });
        this.updateHUD();
    },
    updateHUD() {
        document.getElementById('v-size').innerText = Math.floor(Game.p.r);
        document.getElementById('v-lives').innerText = Game.p.lives;
    },
    cd(k, val) {
        const pct = (val/CFG.SKILLS[k].cd)*100;
        document.getElementById(`c-${k}`).style.height = pct+'%';
        const b = document.getElementById(`s-${k}`);
        if(val<=0) b.classList.add('active'); else b.classList.remove('active');
    },
    floatText(txt, x, y, color) {
        if(x<0||x>Game.W||y<0||y>Game.H) return;
        const d = document.createElement('div'); d.className='float-txt'; d.innerText=txt;
        d.style.left=x+'px'; d.style.top=y+'px'; d.style.color=color;
        document.getElementById('ui-layer').appendChild(d);
        setTimeout(()=>d.remove(), 1000);
    }
};

window.onload = () => { Game.init(); UI.show('p-pass'); };
</script>
</body>
</html>
