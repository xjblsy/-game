<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Deep Sea Evolution: Pro</title>
    <style>
        /* --- å…¨å±€æ ·å¼è®¾å®š --- */
        :root {
            --neon-blue: #00f2fe;
            --neon-purple: #bd00ff;
            --neon-gold: #ffd700;
            --neon-red: #ff0055;
            --glass-bg: rgba(8, 15, 30, 0.92);
            --border-light: rgba(255, 255, 255, 0.15);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif; }
        
        body {
            background-color: #000;
            overflow: hidden;
            width: 100vw; height: 100vh;
            color: #fff;
            display: flex; justify-content: center; align-items: center;
        }

        canvas { display: block; position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* --- UI å®¹å™¨ --- */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10;
            pointer-events: none; /* è®©é¼ æ ‡ç©¿é€UIå±‚ç‚¹å‡»æ¸¸æˆ */
        }

        /* --- ç»ç’ƒæ‹Ÿæ€é¢æ¿ --- */
        .panel {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: var(--glass-bg);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid var(--border-light);
            border-radius: 24px;
            padding: 50px;
            text-align: center;
            box-shadow: 0 20px 50px rgba(0,0,0,0.8), inset 0 0 0 1px rgba(255,255,255,0.05);
            min-width: 450px;
            pointer-events: auto;
            opacity: 0;
            transition: opacity 0.4s ease, transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            display: none;
        }

        .panel.active {
            opacity: 1;
            display: block;
            transform: translate(-50%, -50%) scale(1);
        }

        /* --- æ ‡é¢˜ä¸æ–‡æœ¬ --- */
        h1 {
            font-size: 3rem;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #fff 0%, var(--neon-blue) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(0, 242, 254, 0.3);
            letter-spacing: 2px;
        }

        p { color: #8892b0; margin-bottom: 25px; font-size: 1rem; }

        /* --- è¾“å…¥æ¡† --- */
        .input-group { position: relative; margin-bottom: 25px; }
        input {
            width: 100%;
            padding: 16px 20px;
            background: rgba(0, 0, 0, 0.4);
            border: 2px solid #2a3b55;
            border-radius: 12px;
            color: #fff;
            font-size: 1.2rem;
            text-align: center;
            transition: 0.3s;
            outline: none;
            letter-spacing: 1px;
        }
        input:focus { border-color: var(--neon-blue); box-shadow: 0 0 20px rgba(0, 242, 254, 0.2); }

        /* --- æŒ‰é’® --- */
        .btn {
            background: linear-gradient(90deg, #0061ff 0%, #60efff 100%);
            border: none;
            padding: 15px 40px;
            color: #000;
            font-weight: 800;
            font-size: 1.1rem;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 10px 20px rgba(0, 242, 254, 0.3);
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .btn:hover { transform: translateY(-3px); box-shadow: 0 15px 30px rgba(0, 242, 254, 0.5); }
        .btn:active { transform: translateY(1px); }
        .btn-outline { background: transparent; border: 2px solid var(--border-light); color: #fff; box-shadow: none; }
        .btn-outline:hover { border-color: #fff; background: rgba(255,255,255,0.05); }

        /* --- å­˜æ¡£åˆ—è¡¨ --- */
        .slot-container {
            max-height: 250px; overflow-y: auto; margin: 20px 0;
            scrollbar-width: thin; scrollbar-color: var(--neon-blue) transparent;
        }
        .slot-card {
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.05);
            padding: 15px 20px;
            margin-bottom: 12px;
            border-radius: 12px;
            display: flex; justify-content: space-between; align-items: center;
            transition: 0.3s; cursor: pointer;
        }
        .slot-card:hover { background: rgba(0, 242, 254, 0.1); border-color: var(--neon-blue); transform: scale(1.02); }
        .slot-info h3 { font-size: 1.1rem; color: #fff; margin-bottom: 4px; }
        .slot-info span { font-size: 0.8rem; color: #64748b; }
        .del-btn { color: var(--neon-red); font-weight: bold; padding: 5px 10px; border-radius: 8px; transition: 0.2s; }
        .del-btn:hover { background: rgba(255, 0, 85, 0.1); }

        /* --- HUD (æ¸¸æˆå†…ç•Œé¢) --- */
        #hud { display: none; }
        .hud-stats {
            position: absolute; top: 30px; left: 30px;
            display: flex; gap: 20px;
        }
        .stat-pill {
            background: rgba(0,0,0,0.6); backdrop-filter: blur(5px);
            padding: 10px 20px; border-radius: 30px;
            border: 1px solid rgba(255,255,255,0.1);
            font-weight: bold; display: flex; align-items: center; gap: 8px;
        }
        
        .skill-dock {
            position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 15px; pointer-events: auto;
        }
        .skill-node {
            width: 70px; height: 70px;
            background: rgba(10, 20, 40, 0.8);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 16px;
            position: relative; overflow: hidden;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            transition: 0.2s;
        }
        .skill-node.active { border-color: var(--neon-gold); box-shadow: 0 0 20px rgba(255, 215, 0, 0.4); }
        .skill-icon { font-size: 1.5rem; z-index: 2; }
        .skill-key { font-size: 0.7rem; color: rgba(255,255,255,0.5); margin-top: 4px; z-index: 2; font-weight: bold; }
        .skill-cd {
            position: absolute; bottom: 0; left: 0; width: 100%; height: 0%;
            background: rgba(0,0,0,0.7); z-index: 3; transition: height 0.1s linear;
        }

        /* --- æµ®åŠ¨æ–‡å­—ç‰¹æ•ˆ --- */
        .float-txt {
            position: absolute; font-weight: 900; font-size: 1.5rem;
            pointer-events: none; text-shadow: 0 2px 4px rgba(0,0,0,0.8);
            animation: floatUpFade 0.8s forwards ease-out;
        }
        @keyframes floatUpFade { 0% { opacity:1; transform:translate(-50%, 0) scale(1); } 100% { opacity:0; transform:translate(-50%, -60px) scale(1.2); } }

        /* é”™è¯¯éœ‡åŠ¨åŠ¨ç”» */
        .shake { animation: shake 0.4s cubic-bezier(.36,.07,.19,.97) both; }
        @keyframes shake { 10%, 90% { transform: translate3d(-1px, 0, 0); } 20%, 80% { transform: translate3d(2px, 0, 0); } 30%, 50%, 70% { transform: translate3d(-4px, 0, 0); } 40%, 60% { transform: translate3d(4px, 0, 0); } }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        
        <div id="panel-pass" class="panel active">
            <h1>ACCESS CONTROL</h1>
            <p>è¯·è¾“å…¥æ·±æµ·æœ€é«˜æƒé™å¯†é’¥</p>
            <div class="input-group">
                <input type="password" id="inp-global-pass" placeholder="Password">
            </div>
            <button class="btn" onclick="App.checkGlobalPass()">è§£é”ç»ˆç«¯</button>
            <p id="err-pass" style="color:var(--neon-red); margin-top:15px; display:none;">å¯†é’¥é”™è¯¯</p>
        </div>

        <div id="panel-login" class="panel">
            <h1>IDENTITY</h1>
            <p>å»ºç«‹ç¥ç»è¿æ¥ (è¾“å…¥æ‹¼éŸ³é¦–å­—æ¯)</p>
            <div class="input-group">
                <input type="text" id="inp-username" maxlength="8" placeholder="ä¾‹å¦‚: ZHANGSAN">
            </div>
            <button class="btn" onclick="App.loginUser()">è¿æ¥ç³»ç»Ÿ</button>
        </div>

        <div id="panel-saves" class="panel">
            <h1 style="font-size: 2rem;">ARCHIVES</h1>
            <p id="welcome-text">æ¬¢è¿å›æ¥ï¼ŒæŒ‡æŒ¥å®˜</p>
            <div class="slot-container" id="slot-list"></div>
            <div style="margin-top: 20px; display:flex; justify-content:center; gap:15px;">
                <button class="btn" onclick="App.createGame()">æ–°å¾ç¨‹</button>
                <button class="btn btn-outline" onclick="App.logout()">æ–­å¼€è¿æ¥</button>
            </div>
        </div>

        <div id="panel-intermission" class="panel">
            <h1 id="level-title" style="color:var(--neon-gold);">éœ¸ä¸»é™ä¸´</h1>
            <p id="level-desc">æµ…æ»©å·²è¢«å¾æœã€‚</p>
            <div style="margin: 30px 0; text-align: left; background: rgba(0,0,0,0.3); padding: 20px; border-radius: 10px;">
                <p style="margin:0 0 10px 0; color:#fff;">ä¸‹ä¸€åŒºåŸŸ: <span style="color:var(--neon-red); font-weight:bold;">æ·±æ¸Šæµ·æ²Ÿ</span></p>
                <ul style="color:#aaa; font-size:0.9rem; padding-left:20px;">
                    <li>ç¯å¢ƒï¼šç»å¯¹é»‘æš— (éœ€è¦è‡ªè¡Œæ¢ç´¢)</li>
                    <li>å¨èƒï¼šå—œè¡€é²¨ (ä¸»åŠ¨è¿½å‡»)ã€ç¯ç¬¼é±¼</li>
                    <li>æ–°å¢æŠ€èƒ½ï¼šå£°çº³å†²å‡» (Lé”®) - éœ‡æ™•å…¨åœº</li>
                </ul>
            </div>
            <div style="display:flex; justify-content:center; gap:15px;">
                <button class="btn" onclick="App.nextLevel()">æ½œå…¥æ·±æ¸Š</button>
                <button class="btn btn-outline" onclick="App.saveAndExit()">å­˜æ¡£ä¼‘æ¯</button>
            </div>
        </div>

        <div id="panel-gameover" class="panel">
            <h1 style="color:var(--neon-red);">ä¿¡å·ä¸¢å¤±</h1>
            <p>ä½ çš„ç”Ÿç‰©è®¯å·å·²æ¶ˆå¤±...</p>
            <button class="btn" onclick="Game.retry()">é‡ç»„åŸºå› </button>
            <button class="btn btn-outline" style="margin-left:15px;" onclick="App.showSaves()">è¿”å›ä¸»é¡µ</button>
        </div>

        <div id="hud">
            <div class="hud-stats">
                <div class="stat-pill" style="border-color:var(--neon-red); color:var(--neon-red);">
                    â¤ <span id="hud-lives">3</span>
                </div>
                <div class="stat-pill" style="border-color:var(--neon-blue); color:var(--neon-blue);">
                    ğŸ“ <span id="hud-size">15</span> / <span id="hud-target">50</span>
                </div>
                <div class="stat-pill">
                    âš“ <span id="hud-zone">Zone 1</span>
                </div>
            </div>

            <div class="skill-dock">
                <div class="skill-node" id="skill-dash">
                    <span class="skill-icon">âš¡</span>
                    <span class="skill-key">SPACE</span>
                    <div class="skill-cd" id="cd-dash"></div>
                </div>
                <div class="skill-node" id="skill-shield">
                    <span class="skill-icon">ğŸ›¡ï¸</span>
                    <span class="skill-key">J</span>
                    <div class="skill-cd" id="cd-shield"></div>
                </div>
                <div class="skill-node" id="skill-magnet">
                    <span class="skill-icon">ğŸ§²</span>
                    <span class="skill-key">K</span>
                    <div class="skill-cd" id="cd-magnet"></div>
                </div>
                <div class="skill-node" id="skill-sonar" style="display:none;">
                    <span class="skill-icon">ğŸ“¡</span>
                    <span class="skill-key">L</span>
                    <div class="skill-cd" id="cd-sonar"></div>
                </div>
            </div>
        </div>
    </div>

<script>
/**
 * é«˜çº§æ¸¸æˆå¼•æ“ - Deep Sea Evolution Pro
 */

/* --- é…ç½®å¸¸é‡ --- */
const CFG = {
    GlobalPass: 'xjblsy99', // æ ¸å¿ƒè¦æ±‚
    MaxSaves: 4,
    Levels: [
        {
            id: 0, name: "é˜³å…‰æµ…æ»©", target: 60, startR: 15,
            bgTop: "#006994", bgBot: "#003366", dark: 0,
            skills: ['dash', 'shield', 'magnet'],
            spawns: ['tetra', 'goldie', 'ray']
        },
        {
            id: 1, name: "æ·±æ¸Šæµ·æ²Ÿ", target: 200, startR: 65,
            bgTop: "#090909", bgBot: "#1a0b2e", dark: 0.88,
            skills: ['dash', 'shield', 'magnet', 'sonar'],
            spawns: ['goldie', 'angler', 'shark', 'whale']
        }
    ],
    Skills: {
        dash:   { cd: 3000, dur: 300,  cost: 0, color: '#00f2fe' },
        shield: { cd: 12000, dur: 3000, cost: 0, color: '#ffd700' },
        magnet: { cd: 15000, dur: 4000, cost: 0, color: '#bd00ff', radius: 350 },
        sonar:  { cd: 20000, dur: 100,  cost: 0, color: '#fff', radius: 800 } // çœ©æ™•å…¨å±
    },
    FishTypes: {
        tetra:  { r: [5, 12],   spd: 2.5, color: '#ff00cc', skin: 'neon' },
        goldie: { r: [12, 25],  spd: 1.8, color: '#ff9f43', skin: 'gold' },
        ray:    { r: [20, 35],  spd: 2.2, color: '#00d2d3', skin: 'flat' },
        angler: { r: [35, 55],  spd: 1.4, color: '#a55eea', skin: 'angler' }, // ç¯ç¬¼é±¼
        shark:  { r: [50, 80],  spd: 3.2, color: '#576574', skin: 'shark', aggro: true },
        whale:  { r: [90, 150], spd: 0.8, color: '#2f3542', skin: 'whale' }
    }
};

/* --- æ¸²æŸ“æ ¸å¿ƒ (Visuals) --- */
const Renderer = {
    // ç»˜åˆ¶é«˜çº§é±¼ç±» (éª¨éª¼åŠ¨ç”»+ä¼ª3D)
    drawFish(ctx, x, y, r, angle, color, type, tailPhase) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);

        // 1. èº«ä½“æ¸å˜ (ä¼ª3Dæ„Ÿ)
        const grad = ctx.createRadialGradient(0, -r*0.2, r*0.1, 0, 0, r);
        grad.addColorStop(0, this.adjustColor(color, 60)); // é«˜å…‰
        grad.addColorStop(0.5, color);
        grad.addColorStop(1, this.adjustColor(color, -40)); // é˜´å½±

        // 2. å°¾å·´åŠ¨æ€æ¨¡æ‹Ÿ (Sine Wave Spine)
        const swing = Math.sin(tailPhase); 
        ctx.fillStyle = color;
        
        if(type === 'shark') {
            // é²¨é±¼å°¾å·´
            ctx.beginPath();
            ctx.moveTo(-r*0.8, 0);
            ctx.quadraticCurveTo(-r*1.5, swing*r*0.5, -r*2.2, swing*r*0.8 - r*0.8);
            ctx.lineTo(-r*2.2, swing*r*0.8 + r*0.8);
            ctx.quadraticCurveTo(-r*1.5, swing*r*0.5, -r*0.8, 0);
            ctx.fill();
            // èƒŒé³
            ctx.beginPath(); ctx.moveTo(r*0.2, -r*0.5); ctx.lineTo(-r*0.4, -r*1.2); ctx.lineTo(-r*0.2, -r*0.5); ctx.fill();
        } else if (type === 'whale') {
            // é²¸é±¼æ‰å°¾
            ctx.beginPath();
            ctx.moveTo(-r*0.9, 0);
            ctx.quadraticCurveTo(-r*1.8, swing*r*0.3, -r*2.2, -r*0.6);
            ctx.lineTo(-r*2.2, r*0.6);
            ctx.quadraticCurveTo(-r*1.8, swing*r*0.3, -r*0.9, 0);
            ctx.fill();
        } else {
            // æ™®é€šé±¼å°¾
            ctx.beginPath();
            ctx.moveTo(-r*0.7, 0);
            ctx.lineTo(-r*1.6, -r*0.6 + swing*10);
            ctx.lineTo(-r*1.6, r*0.6 + swing*10);
            ctx.fill();
        }

        // 3. ä¾§é³ (å‘¼å¸æ•ˆæœ)
        const finOpen = Math.sin(tailPhase * 0.8) * 0.2;
        ctx.beginPath();
        ctx.ellipse(r*0.1, r*0.6, r*0.4, r*0.2, 0.5 + finOpen, 0, Math.PI*2);
        ctx.ellipse(r*0.1, -r*0.6, r*0.4, r*0.2, -0.5 - finOpen, 0, Math.PI*2);
        ctx.fillStyle = this.adjustColor(color, -20);
        ctx.fill();

        // 4. èº«ä½“ä¸»ä½“
        ctx.beginPath();
        if(type === 'shark') ctx.ellipse(0, 0, r*1.2, r*0.7, 0, 0, Math.PI*2); // æ¢­å½¢
        else if(type === 'whale') ctx.ellipse(0, 0, r*1.1, r*0.9, 0, 0, Math.PI*2); // èƒ–
        else ctx.ellipse(0, 0, r, r*0.8, 0, 0, Math.PI*2); // è›‹å½¢
        ctx.fillStyle = grad;
        ctx.fill();

        // 5. çœ¼ç› (ç¨‹åºåŒ–çœ¼çƒ)
        const eyeX = r * 0.4;
        const eyeY = r * 0.35;
        const eyeSize = r * 0.25;
        
        // ç™½çœ¼çƒ
        ctx.fillStyle = '#fff';
        ctx.beginPath(); ctx.arc(eyeX, -eyeY, eyeSize, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(eyeX, eyeY, eyeSize, 0, Math.PI*2); ctx.fill();
        // é»‘ç³å­”
        ctx.fillStyle = '#000';
        ctx.beginPath(); ctx.arc(eyeX + 2, -eyeY, eyeSize*0.5, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(eyeX + 2, eyeY, eyeSize*0.5, 0, Math.PI*2); ctx.fill();

        // 6. ç‰¹æ®Šéƒ¨ä»¶ (ç¯ç¬¼é±¼ç¯)
        if(type === 'angler') {
            ctx.beginPath();
            ctx.moveTo(r*0.5, -r*0.1);
            ctx.quadraticCurveTo(r*0.8, -r*1.5, r*1.5, -r*1.2);
            ctx.strokeStyle = '#888'; ctx.lineWidth = 2; ctx.stroke();
            
            // ç¯æ³¡
            ctx.beginPath(); ctx.arc(r*1.5, -r*1.2, 6, 0, Math.PI*2);
            ctx.fillStyle = '#ffff00'; ctx.fill();
            ctx.shadowBlur = 15; ctx.shadowColor = '#ffff00'; ctx.fill(); ctx.shadowBlur = 0;
        }

        ctx.restore();
    },

    adjustColor(hex, amt) {
        let usePound = false;
        if (hex[0] == "#") { hex = hex.slice(1); usePound = true; }
        let num = parseInt(hex, 16);
        let r = (num >> 16) + amt; if (r > 255) r = 255; else if (r < 0) r = 0;
        let b = ((num >> 8) & 0x00FF) + amt; if (b > 255) b = 255; else if (b < 0) b = 0;
        let g = (num & 0x0000FF) + amt; if (g > 255) g = 255; else if (g < 0) g = 0;
        return (usePound ? "#" : "") + (g | (b << 8) | (r << 16)).toString(16);
    }
};

/* --- æ¸¸æˆé€»è¾‘ç±» --- */
const Game = {
    canvas: document.getElementById('gameCanvas'),
    ctx: document.getElementById('gameCanvas').getContext('2d'),
    W: 0, H: 0,
    
    state: 'STOP',
    loopId: null,
    
    player: {
        x:0, y:0, vx:0, vy:0, r:0, angle:0, 
        tailPhase:0, lives:3, invincible:0,
        skills: { dash:{cd:0,active:false}, shield:{cd:0,active:false}, magnet:{cd:0,active:false}, sonar:{cd:0,active:false} }
    },
    
    levelIdx: 0,
    saveId: null,
    enemies: [],
    particles: [],
    keys: {},
    camShake: 0,

    init() {
        this.resize();
        window.addEventListener('resize', () => this.resize());
        this.bindInput();
    },

    resize() {
        this.W = window.innerWidth;
        this.H = window.innerHeight;
        this.canvas.width = this.W;
        this.canvas.height = this.H;
    },

    start(lvlIdx, saveId) {
        this.levelIdx = lvlIdx;
        this.saveId = saveId;
        const cfg = CFG.Levels[lvlIdx];

        // Reset Player
        this.player.x = this.W/2; this.player.y = this.H/2;
        this.player.vx = 0; this.player.vy = 0;
        this.player.r = cfg.startR;
        this.player.lives = 3;
        this.player.invincible = 0;
        
        // Reset Skills
        Object.keys(this.player.skills).forEach(k => {
            this.player.skills[k].cd = 0;
            this.player.skills[k].active = false;
        });

        this.enemies = [];
        this.particles = [];
        this.state = 'PLAY';

        UI.showHUD(cfg);
        this.loop();
    },

    retry() {
        this.start(this.levelIdx, this.saveId);
    },

    loop() {
        if(this.state !== 'PLAY') return;

        this.ctx.clearRect(0,0,this.W,this.H);
        this.update();
        this.draw();
        
        this.loopId = requestAnimationFrame(() => this.loop());
    },

    update() {
        const p = this.player;
        const lvl = CFG.Levels[this.levelIdx];
        const dt = 16; // ms

        // 1. ç©å®¶ç‰©ç†
        let acc = 0.5;
        let drag = 0.95;
        let maxSpd = 7 * (30 / (p.r + 20)); // ä½“å‹è¶Šå¤§è¶Šæ…¢

        if(p.skills.dash.active) maxSpd *= 2.5;

        if(this.keys['ArrowUp'] || this.keys['w']) p.vy -= acc;
        if(this.keys['ArrowDown'] || this.keys['s']) p.vy += acc;
        if(this.keys['ArrowLeft'] || this.keys['a']) p.vx -= acc;
        if(this.keys['ArrowRight'] || this.keys['d']) p.vx += acc;

        p.vx *= drag; p.vy *= drag;
        const spd = Math.sqrt(p.vx**2 + p.vy**2);
        if(spd > maxSpd) { p.vx = (p.vx/spd)*maxSpd; p.vy = (p.vy/spd)*maxSpd; }

        p.x += p.vx; p.y += p.vy;
        p.tailPhase += 0.2 + spd * 0.05;

        // è¾¹ç•Œ
        if(p.x < p.r) p.x = p.r; if(p.x > this.W-p.r) p.x = this.W-p.r;
        if(p.y < p.r) p.y = p.r; if(p.y > this.H-p.r) p.y = this.H-p.r;

        if(spd > 0.1) p.angle = Math.atan2(p.vy, p.vx);

        // 2. æ•Œäººç”Ÿæˆä¸AI
        if(this.enemies.length < 18 && Math.random() < 0.02) this.spawnEnemy(lvl);

        this.enemies.forEach((e, i) => {
            // AIé€»è¾‘
            if(e.stunned > 0) {
                e.stunned--;
                e.vx *= 0.9; e.vy *= 0.9;
            } else {
                // é²¨é±¼è¿½å‡»
                if(e.aggro && !p.skills.shield.active) {
                    const dx = p.x - e.x, dy = p.y - e.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if(dist < 500) {
                        e.vx += (dx/dist) * 0.2;
                        e.vy += (dy/dist) * 0.2;
                    }
                }
                // ç£å¸æ•ˆæœ
                if(p.skills.magnet.active && e.r < p.r) {
                    const dx = p.x - e.x, dy = p.y - e.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if(dist < CFG.Skills.magnet.radius) {
                        e.vx += (dx/dist) * 0.8;
                        e.vy += (dy/dist) * 0.8;
                    }
                }
                e.x += e.vx; e.y += e.vy;
            }
            
            // åŠ¨ç”»ç›¸ä½
            const es = Math.sqrt(e.vx**2 + e.vy**2);
            e.tailPhase += 0.15 + es * 0.05;
            if(es > 0.1) e.angle = Math.atan2(e.vy, e.vx);

            // ç§»é™¤å‡ºç•Œ
            if(e.x < -200 || e.x > this.W+200 || e.y < -200 || e.y > this.H+200) {
                this.enemies.splice(i, 1); return;
            }

            // ç¢°æ’æ£€æµ‹
            const dist = Math.hypot(p.x - e.x, p.y - e.y);
            if(dist < p.r + e.r * 0.8) {
                if(p.r > e.r * 1.1) {
                    // åƒæ‰
                    this.eat(e, i);
                } else if (e.r > p.r) {
                    // å—ä¼¤
                    if(p.invincible <= 0 && !p.skills.shield.active) {
                        this.damage();
                    }
                }
            }
        });

        // 3. ç²’å­æ›´æ–°
        for(let i=this.particles.length-1; i>=0; i--) {
            let pt = this.particles[i];
            pt.x += pt.vx; pt.y += pt.vy;
            pt.life -= 0.02;
            if(pt.life <= 0) this.particles.splice(i, 1);
        }

        // 4. æŠ€èƒ½CDæ›´æ–°
        for(let k in p.skills) {
            if(p.skills[k].cd > 0) {
                p.skills[k].cd -= dt;
                UI.updateSkill(k, p.skills[k].cd);
            }
        }

        if(this.camShake > 0) {
            this.ctx.translate((Math.random()-0.5)*this.camShake, (Math.random()-0.5)*this.camShake);
            this.camShake *= 0.9;
        }
    },

    spawnEnemy(lvl) {
        const typeKey = lvl.spawns[Math.floor(Math.random() * lvl.spawns.length)];
        const proto = CFG.FishTypes[typeKey];
        
        const side = Math.random() > 0.5;
        let e = {
            x: side ? -100 : this.W + 100,
            y: Math.random() * this.H,
            vx: (side ? 1 : -1) * proto.spd,
            vy: (Math.random()-0.5) * 0.5,
            r: proto.r[0] + Math.random()*(proto.r[1]-proto.r[0]),
            color: proto.color,
            skin: proto.skin,
            aggro: proto.aggro || false,
            angle: 0, tailPhase: 0, stunned: 0
        };
        
        // åŠ¨æ€éš¾åº¦ï¼šå¦‚æœç©å®¶å¾ˆå¤§ï¼Œå¢åŠ å¤§é±¼ç”Ÿæˆç‡
        if(this.player.r > 100 && !e.aggro && Math.random()<0.3) e.r *= 1.5; 

        this.enemies.push(e);
    },

    eat(e, idx) {
        this.enemies.splice(idx, 1);
        this.player.r += e.r * 0.08;
        const score = Math.floor(e.r);
        UI.addFloatingText(`+${score}`, e.x, e.y, '#ffd700');
        
        // ç²’å­ç‰¹æ•ˆ
        for(let n=0; n<8; n++) {
            this.particles.push({
                x: e.x, y: e.y,
                vx: (Math.random()-0.5)*8, vy: (Math.random()-0.5)*8,
                r: Math.random()*4+2, color: e.color, life: 1
            });
        }

        UI.updateHUDData();

        // æ£€æŸ¥é€šå…³
        if(this.player.r >= CFG.Levels[this.levelIdx].target) {
            this.levelComplete();
        }
    },

    damage() {
        this.player.lives--;
        this.player.invincible = 120; // 2ç§’
        this.camShake = 20;
        UI.updateLives();
        UI.addFloatingText("å±é™©!", this.player.x, this.player.y - 50, '#ff0055');
        
        // è¡€è…¥ç‰¹æ•ˆ
        for(let n=0; n<15; n++) {
            this.particles.push({
                x: this.player.x, y: this.player.y,
                vx: (Math.random()-0.5)*15, vy: (Math.random()-0.5)*15,
                r: Math.random()*5, color: '#ff0000', life: 1
            });
        }

        if(this.player.lives <= 0) {
            this.state = 'OVER';
            UI.showPanel('panel-gameover');
        }
    },

    draw() {
        const ctx = this.ctx;
        const p = this.player;
        const lvl = CFG.Levels[this.levelIdx];

        // 1. èƒŒæ™¯
        const bgGrad = ctx.createLinearGradient(0, 0, 0, this.H);
        bgGrad.addColorStop(0, lvl.bgTop);
        bgGrad.addColorStop(1, lvl.bgBot);
        ctx.fillStyle = bgGrad;
        ctx.fillRect(0,0,this.W,this.H);

        // 2. æ·±æµ·é»‘æš—ä¸ç¯å…‰ (å¦‚æœæ˜¯æ·±æµ·)
        if(lvl.dark > 0) {
            ctx.fillStyle = `rgba(0,0,0,${lvl.dark})`;
            ctx.fillRect(0,0,this.W,this.H);
            
            ctx.globalCompositeOperation = 'destination-out'; // æŒ–æ´æ¨¡å¼
            
            // ç©å®¶å…‰ç¯
            let glowR = p.r * 4 + 200;
            let g = ctx.createRadialGradient(p.x, p.y, p.r, p.x, p.y, glowR);
            g.addColorStop(0, 'rgba(0,0,0,1)');
            g.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = g;
            ctx.beginPath(); ctx.arc(p.x, p.y, glowR, 0, Math.PI*2); ctx.fill();

            // ç¯ç¬¼é±¼å…‰ç¯
            this.enemies.forEach(e => {
                if(e.skin === 'angler') {
                    let eg = ctx.createRadialGradient(e.x, e.y, e.r, e.x, e.y, e.r*4);
                    eg.addColorStop(0, 'rgba(0,0,0,1)');
                    eg.addColorStop(1, 'rgba(0,0,0,0)');
                    ctx.fillStyle = eg;
                    ctx.beginPath(); ctx.arc(e.x, e.y, e.r*4, 0, Math.PI*2); ctx.fill();
                }
            });
            ctx.globalCompositeOperation = 'source-over'; // æ¢å¤
        }

        // 3. ç»˜åˆ¶æŠ€èƒ½ç‰¹æ•ˆ (åº•å±‚)
        // æŠ¤ç›¾
        if(p.skills.shield.active) {
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.r+15, 0, Math.PI*2);
            ctx.fillStyle = 'rgba(255, 215, 0, 0.2)';
            ctx.fill();
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 3;
            ctx.setLineDash([10, 5]);
            ctx.stroke();
            ctx.setLineDash([]);
        }
        // ç£å¸åŠ›åœº
        if(p.skills.magnet.active) {
            ctx.beginPath();
            ctx.arc(p.x, p.y, CFG.Skills.magnet.radius, 0, Math.PI*2);
            ctx.fillStyle = 'rgba(189, 0, 255, 0.05)';
            ctx.fill();
            ctx.strokeStyle = 'rgba(189, 0, 255, 0.2)';
            ctx.lineWidth = 1;
            ctx.stroke();
        }

        // 4. æ•Œäººæ¸²æŸ“ (Advanced)
        this.enemies.forEach(e => {
            Renderer.drawFish(ctx, e.x, e.y, e.r, e.angle, e.color, e.skin, e.tailPhase);
        });

        // 5. ç©å®¶æ¸²æŸ“
        if(p.invincible % 10 < 5) {
            Renderer.drawFish(ctx, p.x, p.y, p.r, p.angle, '#00f2fe', 'player', p.tailPhase);
        }

        // 6. ç²’å­
        this.particles.forEach(pt => {
            ctx.globalAlpha = pt.life;
            ctx.fillStyle = pt.color;
            ctx.beginPath(); ctx.arc(pt.x, pt.y, pt.r, 0, Math.PI*2); ctx.fill();
        });
        ctx.globalAlpha = 1;

        // 7. å£°çº³æ³¢çº¹ç‰¹æ•ˆ (é¡¶å±‚)
        if(p.skills.sonar.active) {
            ctx.beginPath();
            ctx.arc(p.x, p.y, CFG.Skills.sonar.radius, 0, Math.PI*2);
            ctx.strokeStyle = `rgba(255,255,255, ${Math.random()})`;
            ctx.lineWidth = 10;
            ctx.stroke();
        }

        // æ¢å¤Shake
        ctx.setTransform(1, 0, 0, 1, 0, 0); 
    },

    bindInput() {
        window.addEventListener('keydown', e => {
            this.keys[e.key] = true;
            if(this.state === 'PLAY') {
                if(e.code === 'Space') this.castSkill('dash');
                if(e.code === 'KeyJ') this.castSkill('shield');
                if(e.code === 'KeyK') this.castSkill('magnet');
                if(e.code === 'KeyL') this.castSkill('sonar');
            }
        });
        window.addEventListener('keyup', e => this.keys[e.key] = false);
    },

    castSkill(name) {
        if(!CFG.Levels[this.levelIdx].skills.includes(name)) return;
        
        let s = this.player.skills[name];
        let cfg = CFG.Skills[name];
        if(s.cd <= 0 && !s.active) {
            s.active = true;
            s.cd = cfg.cd;
            
            // é€»è¾‘è§¦å‘
            if(name === 'sonar') {
                this.camShake = 30;
                this.enemies.forEach(e => e.stunned = 180); // 3ç§’çœ©æ™•
                UI.addFloatingText("SONAR BLAST!", this.player.x, this.player.y-50, '#fff');
            } else {
                UI.addFloatingText(name.toUpperCase(), this.player.x, this.player.y-50, cfg.color);
            }

            setTimeout(() => { s.active = false; }, cfg.dur);
        }
    },

    levelComplete() {
        this.state = 'PAUSED';
        UI.showIntermission();
    }
};

/* --- åº”ç”¨ç¨‹åºæ§åˆ¶ (UI & Save) --- */
const App = {
    user: null,

    checkGlobalPass() {
        const inp = document.getElementById('inp-global-pass');
        const err = document.getElementById('err-pass');
        if (inp.value === CFG.GlobalPass) {
            UI.showPanel('panel-login');
        } else {
            err.style.display = 'block';
            inp.parentElement.classList.add('shake');
            setTimeout(() => inp.parentElement.classList.remove('shake'), 500);
            inp.value = '';
        }
    },

    loginUser() {
        const inp = document.getElementById('inp-username');
        const val = inp.value.trim().toUpperCase();
        if(val && /^[A-Z]+$/.test(val)) {
            this.user = val;
            this.showSaves();
        } else {
            alert("ä»£å·æ— æ•ˆï¼šè¯·è¾“å…¥çº¯å­—æ¯ (ä¾‹å¦‚: BOSS)");
        }
    },

    logout() {
        this.user = null;
        UI.showPanel('panel-login');
    },

    showSaves() {
        UI.showPanel('panel-saves');
        document.getElementById('hud').style.display = 'none';
        document.getElementById('welcome-text').innerText = `æ¬¢è¿å›æ¥ï¼ŒæŒ‡æŒ¥å®˜ ${this.user}`;
        
        const list = document.getElementById('slot-list');
        list.innerHTML = '';
        
        const saves = this.getSaves();
        if(saves.length === 0) list.innerHTML = '<div style="color:#666; padding:20px;">æš‚æ— ä½œæˆ˜è®°å½•</div>';

        saves.forEach(s => {
            const lvlName = CFG.Levels[s.level] ? CFG.Levels[s.level].name : "æœªçŸ¥åŒºåŸŸ";
            const el = document.createElement('div');
            el.className = 'slot-card';
            el.innerHTML = `
                <div class="slot-info" onclick="Game.start(${s.level}, ${s.id})">
                    <h3>${lvlName}</h3>
                    <span>ä½“å‹: ${Math.floor(s.score)} | ${s.date}</span>
                </div>
                <div class="del-btn" onclick="App.delSave(${s.id})">åˆ é™¤</div>
            `;
            list.appendChild(el);
        });
    },

    createGame() {
        const saves = this.getSaves();
        if(saves.length >= CFG.MaxSaves) return alert("å­˜æ¡£æ§½ä½å·²æ»¡ï¼Œè¯·å…ˆåˆ é™¤æ—§å­˜æ¡£ã€‚");
        Game.start(0, null); // Start Level 0
    },

    getSaves() {
        const raw = localStorage.getItem(`DSE_USER_${this.user}`);
        return raw ? JSON.parse(raw) : [];
    },

    saveGame(lvlIdx, score) {
        let saves = this.getSaves();
        const now = new Date().toLocaleDateString();
        
        if (Game.saveId) {
            // Update
            const idx = saves.findIndex(s => s.id === Game.saveId);
            if(idx !== -1) {
                saves[idx].level = lvlIdx;
                saves[idx].score = score;
                saves[idx].date = now;
            }
        } else {
            // New
            Game.saveId = Date.now();
            saves.push({ id: Game.saveId, level: lvlIdx, score: score, date: now });
        }
        localStorage.setItem(`DSE_USER_${this.user}`, JSON.stringify(saves));
    },

    delSave(id) {
        if(!confirm("ç¡®è®¤é”€æ¯æ­¤æ•°æ®ï¼Ÿ")) return;
        let saves = this.getSaves();
        saves = saves.filter(s => s.id !== id);
        localStorage.setItem(`DSE_USER_${this.user}`, JSON.stringify(saves));
        this.showSaves();
    },

    nextLevel() {
        const next = Game.levelIdx + 1;
        this.saveGame(next, Game.player.r); // Save progress
        Game.start(next, Game.saveId);
    },

    saveAndExit() {
        const next = Math.min(Game.levelIdx + 1, CFG.Levels.length-1);
        this.saveGame(next, Game.player.r);
        this.showSaves();
    }
};

/* --- UI è¾…åŠ©ç±» --- */
const UI = {
    showPanel(id) {
        document.querySelectorAll('.panel').forEach(p => p.classList.remove('active'));
        document.getElementById(id).classList.add('active');
    },

    showHUD(lvlCfg) {
        this.showPanel(''); // Hide all panels
        document.getElementById('hud').style.display = 'block';
        document.getElementById('hud-target').innerText = lvlCfg.target;
        document.getElementById('hud-zone').innerText = lvlCfg.name;
        
        // Toggle Skill Icons based on level config
        ['dash', 'shield', 'magnet', 'sonar'].forEach(s => {
            const el = document.getElementById(`skill-${s}`);
            el.style.display = lvlCfg.skills.includes(s) ? 'flex' : 'none';
        });

        this.updateHUDData();
    },

    updateHUDData() {
        document.getElementById('hud-size').innerText = Math.floor(Game.player.r);
    },

    updateLives() {
        document.getElementById('hud-lives').innerText = Game.player.lives;
    },

    updateSkill(name, currentCd) {
        const maxCd = CFG.Skills[name].cd;
        const pct = (currentCd / maxCd) * 100;
        const bar = document.getElementById(`cd-${name}`);
        const node = document.getElementById(`skill-${name}`);
        
        bar.style.height = pct + '%';
        if(currentCd <= 0) node.classList.add('active');
        else node.classList.remove('active');
    },

    addFloatingText(txt, x, y, color) {
        const el = document.createElement('div');
        el.className = 'float-txt';
        el.innerText = txt;
        el.style.left = x + 'px';
        el.style.top = y + 'px';
        el.style.color = color;
        document.getElementById('ui-layer').appendChild(el);
        setTimeout(() => el.remove(), 800);
    },

    showIntermission() {
        document.getElementById('hud').style.display = 'none';
        this.showPanel('panel-intermission');
        if(Game.levelIdx + 1 >= CFG.Levels.length) {
            document.getElementById('level-title').innerText = "æ·±æ¸Šä¹‹ä¸»";
            document.getElementById('level-desc').innerText = "ä½ å·²å¾æœäº†ç›®å‰æ‰€æœ‰å·²çŸ¥æµ·åŸŸã€‚";
        }
    }
};

// åˆå§‹åŒ–
Game.init();

</script>
</body>
</html>
