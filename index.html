<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Deep Sea Evolution: Abyss</title>
    <style>
        :root {
            --neon-cyan: #00f2fe;
            --neon-pink: #ff0055;
            --neon-gold: #ffd700;
            --deep-bg: #000510;
            --glass: rgba(20, 30, 50, 0.85);
        }

        body {
            margin: 0; padding: 0;
            background-color: var(--deep-bg);
            overflow: hidden;
            font-family: 'Segoe UI', sans-serif;
            color: white;
            user-select: none;
        }

        /* æ¸¸æˆç”»å¸ƒ */
        canvas {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 1;
        }

        /* UI äº¤äº’å±‚ */
        #ui-layer {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 100;
            pointer-events: none; /* å…³é”®ï¼šå…è®¸ç‚¹å‡»ç©¿é€ */
        }

        /* é€šç”¨é¢æ¿ */
        .panel {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            background: var(--glass);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 20px 50px rgba(0,0,0,0.8);
            padding: 40px; border-radius: 20px;
            text-align: center; min-width: 380px;
            pointer-events: auto;
            opacity: 0; visibility: hidden;
            transition: 0.3s cubic-bezier(0.18, 0.89, 0.32, 1.28);
        }
        .panel.active { opacity: 1; visibility: visible; transform: translate(-50%, -50%) scale(1); }

        h1 { margin-bottom: 20px; background: linear-gradient(to right, #fff, var(--neon-cyan)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; letter-spacing: 2px; }
        
        input {
            background: rgba(0,0,0,0.5); border: 2px solid #444;
            color: #fff; padding: 15px; width: 100%; border-radius: 12px;
            font-size: 1.1rem; text-align: center; margin-bottom: 20px; outline: none;
            transition: 0.3s;
        }
        input:focus { border-color: var(--neon-cyan); box-shadow: 0 0 20px rgba(0, 242, 254, 0.2); }

        .btn {
            background: linear-gradient(135deg, #00c6ff, #0072ff);
            border: none; padding: 14px 40px; border-radius: 50px;
            color: #fff; font-weight: bold; font-size: 1rem; cursor: pointer;
            box-shadow: 0 10px 20px rgba(0,0,0,0.3); transition: 0.2s;
        }
        .btn:hover { transform: translateY(-3px); box-shadow: 0 15px 30px rgba(0, 242, 254, 0.3); }
        .btn.outline { background: transparent; border: 1px solid rgba(255,255,255,0.3); box-shadow: none; margin-top: 10px; }

        /* å­˜æ¡£æ§½ */
        .slot-list { max-height: 250px; overflow-y: auto; text-align: left; margin: 20px 0; }
        .slot {
            padding: 15px; background: rgba(255,255,255,0.05); border-radius: 10px;
            margin-bottom: 10px; cursor: pointer; display: flex; justify-content: space-between;
            border: 1px solid transparent; transition: 0.2s;
        }
        .slot:hover { border-color: var(--neon-cyan); background: rgba(0,242,254,0.1); }

        /* HUD */
        #hud { display: none; }
        .hud-top { position: absolute; top: 20px; left: 20px; display: flex; gap: 15px; pointer-events: none; }
        .stat { 
            background: rgba(0,0,0,0.7); padding: 8px 16px; border-radius: 30px; 
            border: 1px solid rgba(255,255,255,0.1); font-weight: bold; 
            display: flex; align-items: center; gap: 5px;
        }

        /* æŠ€èƒ½æ  */
        .skill-bar {
            position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 20px; pointer-events: auto;
        }
        .skill-box {
            width: 70px; height: 70px; background: rgba(10,20,30,0.9);
            border: 2px solid #444; border-radius: 16px; position: relative;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            overflow: hidden; transition: 0.2s;
        }
        .skill-box.active { border-color: var(--neon-gold); box-shadow: 0 0 25px rgba(255, 215, 0, 0.4); }
        .skill-icon { font-size: 1.8rem; z-index: 2; }
        .skill-key { font-size: 0.7rem; color: #aaa; margin-top: 4px; z-index: 2; font-weight: bold; }
        .cd-overlay { 
            position: absolute; bottom: 0; left: 0; width: 100%; height: 0%; 
            background: rgba(0,0,0,0.8); z-index: 1; transition: height 0.1s linear;
        }

        /* æµ®åŠ¨æ–‡å­— */
        .float-txt {
            position: absolute; font-weight: 900; font-size: 1.5rem; pointer-events: none;
            text-shadow: 0 2px 10px black; animation: floatUp 1s cubic-bezier(0.23, 1, 0.32, 1) forwards;
        }
        @keyframes floatUp { 0% { transform: translateY(0) scale(1); opacity: 1; } 100% { transform: translateY(-80px) scale(1.2); opacity: 0; } }

        /* è°ƒè¯•ä¿¡æ¯ */
        #debug-log {
            position: absolute; top: 0; right: 0; background: red; color: white; font-size: 12px;
            padding: 5px; z-index: 9999; display: none;
        }
    </style>
</head>
<body>

    <div id="debug-log"></div>
    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div id="p-pass" class="panel active">
            <h1>SYSTEM ACCESS</h1>
            <p>è¯·è¾“å…¥æ·±æµ·æœ€é«˜æƒé™å¯†é’¥</p>
            <input type="password" id="inp-pass" placeholder="Password">
            <button class="btn" onclick="App.verifyPass()">è§£é”ç»ˆç«¯</button>
        </div>

        <div id="p-login" class="panel">
            <h1>IDENTITY</h1>
            <p>è¯·è¾“å…¥ä»£å· (æ‹¼éŸ³é¦–å­—æ¯)</p>
            <input type="text" id="inp-user" maxlength="8" placeholder="ä¾‹å¦‚: BOSS">
            <button class="btn" onclick="App.login()">å»ºç«‹è¿æ¥</button>
        </div>

        <div id="p-saves" class="panel">
            <h1>ARCHIVES</h1>
            <div class="slot-list" id="slot-container"></div>
            <button class="btn" onclick="App.startGame(0, null)">å¼€å§‹æ–°å¾ç¨‹</button>
            <br>
            <button class="btn outline" onclick="UI.show('p-login')">é€€å‡ºç™»å½•</button>
        </div>

        <div id="p-win" class="panel">
            <h1 style="color:var(--neon-gold)">DOMINATED</h1>
            <p>æµ·åŸŸå·²å¾æœ</p>
            <div style="text-align: left; background:rgba(255,255,255,0.05); padding:15px; border-radius:10px; margin:20px 0;">
                <p style="margin:0; color:#fff;">ä¸‹ä¸€ç«™ï¼š<b style="color:var(--neon-pink)">æ·±æ¸Šç¦åŒº</b></p>
                <small style="color:#888">è­¦å‘Šï¼šæ£€æµ‹åˆ°å·¨å‹ç”Ÿç‰©ååº” (Bossçº§)</small>
            </div>
            <button class="btn" onclick="Game.nextLevel()">æ½œå…¥æ·±æ¸Š</button>
            <br>
            <button class="btn outline" onclick="App.saveAndQuit()">å­˜æ¡£å¹¶ä¼‘æ¯</button>
        </div>

        <div id="p-dead" class="panel">
            <h1 style="color:var(--neon-pink)">CRITICAL FAILURE</h1>
            <p>ç”Ÿå‘½è®¯å·æ¶ˆå¤±...</p>
            <button class="btn" onclick="Game.retry()">é‡ç»„åŸºå› </button>
            <br>
            <button class="btn outline" onclick="App.loadSavesUI()">è¿”å›ä¸»é¡µ</button>
        </div>

        <div id="hud">
            <div class="hud-top">
                <div class="stat" style="border-left: 4px solid var(--neon-pink)">
                    <span style="color:var(--neon-pink)">â¤</span> <span id="ui-lives">3</span>
                </div>
                <div class="stat" style="border-left: 4px solid var(--neon-cyan)">
                    <span style="color:var(--neon-cyan)">ğŸ“</span> <span id="ui-size">0</span>
                </div>
                <div class="stat">
                    âš“ <span id="ui-zone">Zone 1</span>
                </div>
            </div>

            <div class="skill-bar">
                <div class="skill-box" id="sk-dash">
                    <div class="skill-icon">âš¡</div><div class="skill-key">SPACE</div>
                    <div class="cd-overlay" id="cd-dash"></div>
                </div>
                <div class="skill-box" id="sk-shield">
                    <div class="skill-icon">ğŸ›¡ï¸</div><div class="skill-key">J</div>
                    <div class="cd-overlay" id="cd-shield"></div>
                </div>
                <div class="skill-box" id="sk-magnet">
                    <div class="skill-icon">ğŸ§²</div><div class="skill-key">K</div>
                    <div class="cd-overlay" id="cd-magnet"></div>
                </div>
                <div class="skill-box" id="sk-sonar" style="display:none">
                    <div class="skill-icon">ğŸ“¡</div><div class="skill-key">L</div>
                    <div class="cd-overlay" id="cd-sonar"></div>
                </div>
            </div>
        </div>
    </div>

<script>
/**
 * é”™è¯¯æ•æ‰
 */
window.onerror = function(msg, url, line) {
    document.getElementById('debug-log').style.display = 'block';
    document.getElementById('debug-log').innerHTML += `ERR: ${msg} line ${line}<br>`;
};

/**
 * æ ¸å¿ƒé…ç½®
 */
const CFG = {
    PASS: 'xjblsy99',
    WORLD: 3000, // è¶…å¤§åœ°å›¾
    LEVELS: [
        { id:0, name:"é˜³å…‰æµ…æ»©", target:60, startR:15, dark:0, bg:['#006994','#003366'], skills:['dash','shield','magnet'], spawns:['tetra','goldie','ray'] },
        { id:1, name:"æ·±æ¸Šç¦åŒº", target:200, startR:70, dark:0.96, bg:['#020202','#120c24'], skills:['dash','shield','magnet','sonar'], spawns:['angler','shark','whale'] }
    ],
    FISH: {
        tetra:  { r:[6,14],   spd:3.5, col:'#ff00cc', type:'neon' },
        goldie: { r:[15,28],  spd:2.5, col:'#ff9f43', type:'gold' },
        ray:    { r:[25,40],  spd:2.8, col:'#00d2d3', type:'flat' },
        angler: { r:[40,60],  spd:1.8, col:'#a55eea', type:'angler' },
        shark:  { r:[60,90],  spd:4.2, col:'#7f8fa6', type:'shark', aggro:true },
        whale:  { r:[100,180],spd:1.2, col:'#2f3542', type:'whale' }
    },
    SKILLS: {
        dash: {cd:3000, dur:300}, shield: {cd:12000, dur:3000},
        magnet: {cd:15000, dur:4000, r:500}, sonar: {cd:20000, dur:150, r:1500}
    }
};

/* --- åŸºç¡€æ•°å­¦å·¥å…· (è§£å†³åæ ‡è®¡ç®—é—®é¢˜) --- */
const Vec2 = {
    dist: (a, b) => Math.sqrt((a.x-b.x)**2 + (a.y-b.y)**2),
    angle: (a, b) => Math.atan2(b.y-a.y, b.x-a.x)
};

/* --- å­˜å‚¨å±‚ (Safe Storage) --- */
const Store = {
    mem: {}, available: false,
    init() {
        try { localStorage.setItem('t','1'); localStorage.removeItem('t'); this.available=true; }
        catch(e) { console.log('Storage restricted'); }
    },
    get(k) { return this.available ? localStorage.getItem(k) : this.mem[k]; },
    set(k, v) { if(this.available) localStorage.setItem(k,v); else this.mem[k]=v; }
};
Store.init();

/* --- æ¸²æŸ“å¼•æ“ (éª¨éª¼åŠ¨ç”» & ç²’å­) --- */
const Render = {
    // ç»˜åˆ¶æ‹–å°¾éª¨éª¼ (Inverse Kinematics ç®€åŒ–ç‰ˆ)
    spine(ctx, nodes, r, color) {
        if(nodes.length < 2) return;
        ctx.beginPath();
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        // ä»å¤´éƒ¨å¼€å§‹ç”»
        ctx.moveTo(nodes[0].x, nodes[0].y);
        for(let i=1; i<nodes.length; i++) {
            // é€æ¸å˜ç»†
            ctx.lineWidth = (r*2) * (1 - i/nodes.length);
            ctx.strokeStyle = color;
            ctx.lineTo(nodes[i].x, nodes[i].y);
            ctx.stroke();
            ctx.beginPath(); 
            ctx.moveTo(nodes[i].x, nodes[i].y);
        }
    },

    fish(ctx, f, phase) {
        ctx.save();
        ctx.translate(f.x, f.y);
        ctx.rotate(f.angle);

        const r = f.r;
        const color = f.color;
        const swing = Math.sin(phase);

        // 1. èº«ä½“å…‰æ³½
        const g = ctx.createRadialGradient(0, -r*0.3, r*0.1, 0, 0, r);
        g.addColorStop(0, '#fff'); g.addColorStop(0.3, color); g.addColorStop(1, '#000');

        // 2. å°¾å·´ (ç¨‹åºåŒ–ç»˜åˆ¶)
        ctx.fillStyle = color;
        ctx.beginPath();
        if(f.type === 'shark') {
            ctx.moveTo(-r*0.8,0);
            ctx.quadraticCurveTo(-r*1.6, swing*r*0.6, -r*2.4, -r*0.9+swing*r);
            ctx.lineTo(-r*2.4, r*0.9+swing*r);
            ctx.quadraticCurveTo(-r*1.6, swing*r*0.6, -r*0.8, 0);
        } else {
            ctx.moveTo(-r*0.7,0); ctx.lineTo(-r*1.6, -r*0.6+swing*10); ctx.lineTo(-r*1.6, r*0.6+swing*10);
        }
        ctx.fill();

        // 3. ä¾§é³
        const fAng = 0.8 + Math.sin(phase*0.8)*0.3;
        ctx.beginPath(); ctx.ellipse(r*0.2, r*0.6, r*0.35, r*0.15, fAng, 0, Math.PI*2);
        ctx.ellipse(r*0.2, -r*0.6, r*0.35, r*0.15, -fAng, 0, Math.PI*2);
        ctx.fill();

        // 4. ä¸»ä½“
        ctx.fillStyle = g;
        ctx.beginPath();
        if(f.type === 'shark') ctx.ellipse(0,0, r*1.3, r*0.6, 0, 0, Math.PI*2);
        else if(f.type === 'whale') ctx.ellipse(0,0, r*1.1, r*0.9, 0, 0, Math.PI*2);
        else ctx.ellipse(0,0, r, r*0.75, 0, 0, Math.PI*2);
        ctx.fill();

        // 5. çœ¼ç› (æ€»æ˜¯çœ‹å‘å‰æ–¹)
        ctx.fillStyle='#fff'; 
        ctx.beginPath(); ctx.arc(r*0.4, -r*0.35, r*0.25, 0, 6.28); ctx.fill();
        ctx.beginPath(); ctx.arc(r*0.4, r*0.35, r*0.25, 0, 6.28); ctx.fill();
        ctx.fillStyle='#000';
        ctx.beginPath(); ctx.arc(r*0.45, -r*0.35, r*0.12, 0, 6.28); ctx.fill();
        ctx.beginPath(); ctx.arc(r*0.45, r*0.35, r*0.12, 0, 6.28); ctx.fill();

        // 6. ç¯ç¬¼é±¼ç¯
        if(f.type==='angler') {
            ctx.strokeStyle='#888'; ctx.lineWidth=2;
            ctx.beginPath(); ctx.moveTo(r*0.5, -r*0.2); ctx.quadraticCurveTo(r, -r*1.5, r*1.6, -r*1.2); ctx.stroke();
            ctx.fillStyle='#ff0'; ctx.shadowBlur=20; ctx.shadowColor='#ff0';
            ctx.beginPath(); ctx.arc(r*1.6, -r*1.2, 6, 0, 6.28); ctx.fill(); ctx.shadowBlur=0;
        }

        ctx.restore();
    }
};

/* --- æ¸¸æˆæ ¸å¿ƒé€»è¾‘ --- */
const Game = {
    cvs: null, ctx: null, W: 0, H: 0,
    loopId: null, state: 'STOP',
    
    // æ‘„åƒæœº
    cam: { x: 0, y: 0 },
    
    // ç©å®¶
    p: { x:0, y:0, vx:0, vy:0, r:0, angle:0, tail:0, lives:3, inv:0, skills:{} },
    
    // å®ä½“æ± 
    enemies: [],
    parts: [], // ç²’å­
    grid: [], // èƒŒæ™¯ç½‘æ ¼ç‚¹ (è§£å†³é»‘å±å‚ç…§é—®é¢˜)
    
    keys: {}, lvlIdx: 0, saveId: null, shake: 0,

    init() {
        this.cvs = document.getElementById('gameCanvas');
        this.ctx = this.cvs.getContext('2d');
        this.resize();
        window.addEventListener('resize', () => this.resize());
        this.bindInput();
        
        // é¢„ç”ŸæˆèƒŒæ™¯ç½‘æ ¼ç‚¹
        for(let i=0; i<100; i++) {
            this.grid.push({
                x: Math.random()*CFG.WORLD,
                y: Math.random()*CFG.WORLD,
                r: Math.random()*2+1,
                a: Math.random()*0.3
            });
        }
    },

    resize() {
        this.W = window.innerWidth;
        this.H = window.innerHeight;
        this.cvs.width = this.W;
        this.cvs.height = this.H;
    },

    start(lvl, sid) {
        this.lvlIdx = lvl;
        this.saveId = sid;
        const cfg = CFG.LEVELS[lvl];

        // 1. åˆå§‹åŒ–ä½ç½® (åœ°å›¾ä¸­å¿ƒ)
        this.p.x = CFG.WORLD / 2;
        this.p.y = CFG.WORLD / 2;
        this.p.vx = 0; this.p.vy = 0;
        this.p.r = cfg.startR;
        this.p.lives = 3;
        this.p.inv = 0; // æ— æ•Œæ—¶é—´
        
        // 2. åˆå§‹åŒ–æ‘„åƒæœº (é˜²æ­¢ä¸€å¼€å§‹é»‘å±)
        this.cam.x = this.p.x - this.W/2;
        this.cam.y = this.p.y - this.H/2;

        // 3. é‡ç½®æŠ€èƒ½
        ['dash','shield','magnet','sonar'].forEach(k => {
            this.p.skills[k] = { cd:0, active:false };
        });

        this.enemies = [];
        this.parts = [];
        this.state = 'PLAY';
        
        UI.setupHUD(cfg);
        this.loop();
    },

    nextLevel() { 
        App.save(this.lvlIdx+1, this.p.r);
        this.start(this.lvlIdx+1, this.saveId); 
    },
    
    retry() { this.start(this.lvlIdx, this.saveId); },

    loop() {
        if(this.state !== 'PLAY') return;
        this.update();
        this.draw();
        this.loopId = requestAnimationFrame(() => this.loop());
    },

    update() {
        const p = this.p;
        const lvl = CFG.LEVELS[this.lvlIdx];

        // --- 1. ç©å®¶ç§»åŠ¨ (ç‰©ç†) ---
        let acc = 0.5;
        let max = 8 * (30 / (p.r + 20)); // ä½“å‹è¶Šå¤§è¶Šæ…¢
        if(p.skills.dash.active) max *= 2.5;

        if(this.keys['ArrowUp'] || this.keys['w']) p.vy -= acc;
        if(this.keys['ArrowDown'] || this.keys['s']) p.vy += acc;
        if(this.keys['ArrowLeft'] || this.keys['a']) p.vx -= acc;
        if(this.keys['ArrowRight'] || this.keys['d']) p.vx += acc;

        p.vx *= 0.94; p.vy *= 0.94; // æ‘©æ“¦åŠ›
        
        let spd = Math.sqrt(p.vx**2 + p.vy**2);
        if(spd > max) { p.vx=(p.vx/spd)*max; p.vy=(p.vy/spd)*max; }

        p.x += p.vx; p.y += p.vy;
        
        // è¾¹ç•Œé™åˆ¶
        if(p.x < p.r) p.x=p.r; if(p.x > CFG.WORLD-p.r) p.x=CFG.WORLD-p.r;
        if(p.y < p.r) p.y=p.r; if(p.y > CFG.WORLD-p.r) p.y=CFG.WORLD-p.r;

        if(spd > 0.1) p.angle = Math.atan2(p.vy, p.vx);
        p.tail += 0.2 + spd * 0.05;

        // --- 2. æ‘„åƒæœºè·Ÿéš (Lerp) ---
        let targetX = p.x - this.W/2;
        let targetY = p.y - this.H/2;
        this.cam.x += (targetX - this.cam.x) * 0.1;
        this.cam.y += (targetY - this.cam.y) * 0.1;
        
        if(this.shake > 0) this.shake *= 0.9;

        // --- 3. æ•Œäººç”Ÿæˆ ---
        if(this.enemies.length < 20 && Math.random() < 0.03) {
            this.spawnEnemy(lvl);
        }

        // --- 4. æ•Œäººé€»è¾‘ & ç¢°æ’ ---
        for(let i = this.enemies.length-1; i>=0; i--) {
            let e = this.enemies[i];
            
            // AI è¡Œä¸º
            if(e.stun > 0) {
                e.stun--; e.vx *= 0.9; e.vy *= 0.9;
            } else {
                if(e.aggro && !p.skills.shield.active) {
                    // è¿½å‡»
                    let dx = p.x - e.x, dy = p.y - e.y;
                    let d = Math.sqrt(dx*dx+dy*dy);
                    if(d < 700) { e.vx += (dx/d)*0.2; e.vy += (dy/d)*0.2; }
                }
                if(p.skills.magnet.active && e.r < p.r) {
                    // ç£å¸
                    let dx = p.x - e.x, dy = p.y - e.y;
                    let d = Math.sqrt(dx*dx+dy*dy);
                    if(d < CFG.SKILLS.magnet.r) { e.vx += (dx/d)*0.8; e.vy += (dy/d)*0.8; }
                }
                e.x += e.vx; e.y += e.vy;
            }

            // è§’åº¦æ›´æ–°
            let es = Math.sqrt(e.vx**2 + e.vy**2);
            if(es > 0.1) e.angle = Math.atan2(e.vy, e.vx);
            e.tail += 0.15 + es*0.05;

            // è·ç¦»å‰”é™¤
            if(Math.abs(e.x - p.x) > 2000 || Math.abs(e.y - p.y) > 2000) {
                this.enemies.splice(i, 1); continue;
            }

            // ç¢°æ’æ£€æµ‹
            let dist = Math.sqrt((p.x-e.x)**2 + (p.y-e.y)**2);
            if(dist < p.r + e.r * 0.8) {
                if(p.r > e.r * 1.1) {
                    // åƒæ‰
                    this.enemies.splice(i, 1);
                    p.r += e.r * 0.08;
                    this.boom(e.x, e.y, e.color);
                    UI.floatText(`+${Math.floor(e.r)}`, e.x - this.cam.x, e.y - this.cam.y, '#ffd700');
                    UI.updateHUD();
                    if(p.r >= lvl.target) { this.state='PAUSED'; UI.show('p-win'); }
                } else if (e.r > p.r) {
                    // å—ä¼¤
                    if(p.inv <= 0 && !p.skills.shield.active) {
                        p.lives--; p.inv = 120; this.shake = 25;
                        UI.floatText("W A R N I N G", p.x - this.cam.x, p.y - 50 - this.cam.y, '#ff0055');
                        UI.updateHUD();
                        if(p.lives <= 0) { this.state='OVER'; UI.show('p-dead'); }
                    }
                }
            }
        }
        if(p.inv > 0) p.inv--;

        // --- 5. æŠ€èƒ½ CD ---
        for(let k in p.skills) {
            if(p.skills[k].cd > 0) {
                p.skills[k].cd -= 16;
                UI.cd(k, p.skills[k].cd);
            }
        }

        // --- 6. ç²’å­ ---
        for(let i=this.parts.length-1; i>=0; i--) {
            let pt = this.parts[i];
            pt.x += pt.vx; pt.y += pt.vy; pt.l -= 0.03;
            if(pt.l <= 0) this.parts.splice(i, 1);
        }
    },

    draw() {
        const ctx = this.ctx;
        const p = this.p;
        const lvl = CFG.LEVELS[this.lvlIdx];

        ctx.save();
        
        // 1. åº”ç”¨æ‘„åƒæœº & éœ‡åŠ¨
        let shakeX = (Math.random()-0.5) * this.shake;
        let shakeY = (Math.random()-0.5) * this.shake;
        ctx.translate(-this.cam.x + shakeX, -this.cam.y + shakeY);

        // 2. ç»˜åˆ¶èƒŒæ™¯ (é˜²æ­¢é»‘å±ä¸çŸ¥æ‰€æª)
        // èƒŒæ™¯æ¸å˜
        let g = ctx.createLinearGradient(0,0,0,CFG.WORLD);
        g.addColorStop(0, lvl.bg[0]); g.addColorStop(1, lvl.bg[1]);
        ctx.fillStyle = g;
        ctx.fillRect(0, 0, CFG.WORLD, CFG.WORLD);
        
        // ç»˜åˆ¶è¾¹ç•Œæ¡†
        ctx.strokeStyle = 'rgba(255,255,255,0.1)';
        ctx.lineWidth = 20;
        ctx.strokeRect(0, 0, CFG.WORLD, CFG.WORLD);

        // ç»˜åˆ¶å‚ç…§å°˜åŸƒ (é‡è¦ï¼è§£å†³é»‘å±æ„Ÿ)
        ctx.fillStyle = 'rgba(255,255,255,0.1)';
        this.grid.forEach(d => {
            ctx.beginPath(); ctx.arc(d.x, d.y, d.r, 0, 6.28); ctx.fill();
        });

        // 3. æ·±æµ·å…‰ç…§é®ç½©
        if(lvl.dark > 0) {
            ctx.fillStyle = `rgba(0,0,0,${lvl.dark})`;
            // åªç»˜åˆ¶å±å¹•èŒƒå›´ï¼Œä¼˜åŒ–æ€§èƒ½
            ctx.fillRect(this.cam.x - 50, this.cam.y - 50, this.W + 100, this.H + 100);
            
            ctx.globalCompositeOperation = 'destination-out';
            
            // ç©å®¶è§†é‡
            this.drawLight(p.x, p.y, p.r*5 + 300);
            // ç¯ç¬¼é±¼è§†é‡
            this.enemies.forEach(e => {
                if(e.type === 'angler') this.drawLight(e.x, e.y, e.r*4 + 100);
            });
            
            ctx.globalCompositeOperation = 'source-over';
        }

        // 4. æŠ€èƒ½ç‰¹æ•ˆ
        if(p.skills.shield.active) {
            ctx.strokeStyle = '#ffd700'; ctx.lineWidth = 4; ctx.setLineDash([15,10]);
            ctx.beginPath(); ctx.arc(p.x, p.y, p.r+30, 0, 6.28); ctx.stroke(); ctx.setLineDash([]);
        }
        if(p.skills.magnet.active) {
            ctx.strokeStyle = 'rgba(189,0,255,0.2)'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.arc(p.x, p.y, CFG.SKILLS.magnet.r, 0, 6.28); ctx.stroke();
        }
        if(p.skills.sonar.active) {
            ctx.strokeStyle = 'rgba(255,255,255,0.5)'; ctx.lineWidth = 20;
            ctx.beginPath(); ctx.arc(p.x, p.y, CFG.SKILLS.sonar.r, 0, 6.28); ctx.stroke();
        }

        // 5. å®ä½“ç»˜åˆ¶
        this.enemies.forEach(e => Render.fish(ctx, e, e.tail));
        if(p.inv%10 < 5) Render.fish(ctx, p, p.tail);

        // 6. ç²’å­
        this.parts.forEach(pt => {
            ctx.globalAlpha = pt.l; ctx.fillStyle = pt.color;
            ctx.beginPath(); ctx.arc(pt.x, pt.y, pt.r, 0, 6.28); ctx.fill();
        });
        ctx.globalAlpha = 1;

        ctx.restore();
    },

    drawLight(x, y, r) {
        let g = this.ctx.createRadialGradient(x, y, r*0.1, x, y, r);
        g.addColorStop(0, 'rgba(0,0,0,1)'); g.addColorStop(1, 'rgba(0,0,0,0)');
        this.ctx.fillStyle = g;
        this.ctx.beginPath(); this.ctx.arc(x, y, r, 0, 6.28); this.ctx.fill();
    },

    spawnEnemy(lvl) {
        const k = lvl.spawns[Math.floor(Math.random()*lvl.spawns.length)];
        const proto = CFG.FISH[k];
        
        // ç”Ÿæˆåœ¨æ‘„åƒæœºå¤–
        let ex, ey;
        if(Math.random()>0.5) {
            ex = this.cam.x + (Math.random()>0.5 ? -200 : this.W+200);
            ey = this.cam.y + Math.random()*this.H;
        } else {
            ex = this.cam.x + Math.random()*this.W;
            ey = this.cam.y + (Math.random()>0.5 ? -200 : this.H+200);
        }
        
        // è¾¹ç•Œæ£€æŸ¥
        if(ex<0)ex=0; if(ex>CFG.WORLD)ex=CFG.WORLD;
        if(ey<0)ey=0; if(ey>CFG.WORLD)ey=CFG.WORLD;

        let r = proto.r[0] + Math.random()*(proto.r[1]-proto.r[0]);
        // åŠ¨æ€éš¾åº¦
        if(this.p.r > 100 && !proto.aggro && Math.random()<0.4) r *= 1.5;

        this.enemies.push({
            x:ex, y:ey, vx:(Math.random()-0.5)*proto.spd, vy:(Math.random()-0.5)*proto.spd,
            r:r, color:proto.col, type:proto.type, aggro:proto.aggro,
            angle:0, tail:0, stun:0
        });
    },

    boom(x, y, c) {
        for(let i=0; i<8; i++) this.parts.push({
            x:x, y:y, vx:(Math.random()-0.5)*12, vy:(Math.random()-0.5)*12,
            r:Math.random()*5+2, color:c, l:1
        });
    },

    skill(k) {
        if(!CFG.LEVELS[this.lvlIdx].skills.includes(k)) return;
        const s = this.p.skills[k];
        const cfg = CFG.SKILLS[k];
        if(s.cd <= 0 && !s.active) {
            s.active = true; s.cd = cfg.cd;
            if(k==='sonar') {
                this.shake = 40;
                this.enemies.forEach(e => e.stun = 180);
                UI.floatText("SONAR!", this.p.x - this.cam.x, this.p.y - 50 - this.cam.y, '#fff');
            } else {
                UI.floatText(k.toUpperCase(), this.p.x - this.cam.x, this.p.y - 50 - this.cam.y, '#fff');
            }
            setTimeout(() => s.active = false, cfg.dur);
        }
    },

    bindInput() {
        window.addEventListener('keydown', e => {
            this.keys[e.key] = true;
            if(this.state === 'PLAY') {
                if(e.code==='Space') this.skill('dash');
                if(e.code==='KeyJ') this.skill('shield');
                if(e.code==='KeyK') this.skill('magnet');
                if(e.code==='KeyL') this.skill('sonar');
            } else {
                if(e.key === 'Enter') UI.enter();
            }
        });
        window.addEventListener('keyup', e => this.keys[e.key] = false);
    }
};

/* --- App & UI é€»è¾‘ --- */
const App = {
    user: null,
    
    verifyPass() {
        const v = document.getElementById('inp-pass').value;
        if(v === CFG.PASS) UI.show('p-login');
        else alert('å¯†é’¥æ— æ•ˆ');
    },

    login() {
        const v = document.getElementById('inp-user').value.toUpperCase().trim();
        if(v && /^[A-Z]+$/.test(v)) {
            this.user = v;
            this.loadSaves();
        } else alert('æ ¼å¼é”™è¯¯ (ä»…é™å­—æ¯)');
    },

    loadSaves() {
        UI.show('p-saves');
        const list = document.getElementById('slot-container');
        list.innerHTML = '';
        
        const saves = this.getStorage();
        if(saves.length===0) list.innerHTML = '<div style="color:#aaa">æš‚æ— æ•°æ®</div>';
        
        saves.forEach(s => {
            const d = document.createElement('div');
            d.className = 'slot';
            d.innerHTML = `
                <div onclick="App.startGame(${s.level}, ${s.id})">
                    <b style="color:var(--neon-gold)">${CFG.LEVELS[s.level].name}</b>
                    <span style="font-size:0.8em;color:#888">Size: ${Math.floor(s.score)}</span>
                </div>
                <div style="color:red;padding:0 10px" onclick="App.del(${s.id})">Ã—</div>
            `;
            list.appendChild(d);
        });
    },

    startGame(lvl, sid) {
        Game.start(lvl, sid);
    },

    save(lvl, score) {
        let s = this.getStorage();
        const now = new Date().toLocaleDateString();
        if(Game.saveId) {
            let idx = s.findIndex(x=>x.id===Game.saveId);
            if(idx>=0) { s[idx].level=lvl; s[idx].score=score; }
        } else {
            Game.saveId = Date.now();
            if(s.length>=4) s.shift();
            s.push({id:Game.saveId, level:lvl, score:score, date:now});
        }
        localStorage.setItem(`DSE_${this.user}`, JSON.stringify(s));
    },

    getStorage() {
        try {
            const r = localStorage.getItem(`DSE_${this.user}`);
            return r ? JSON.parse(r) : [];
        } catch(e) { return []; }
    },

    del(id) {
        if(!confirm('åˆ é™¤?')) return;
        let s = this.getStorage().filter(x=>x.id!==id);
        localStorage.setItem(`DSE_${this.user}`, JSON.stringify(s));
        this.loadSaves();
    },

    saveAndQuit() {
        this.save(Math.min(Game.lvlIdx+1, 1), Game.p.r);
        this.loadSavesUI();
    },
    loadSavesUI() { this.loadSaves(); }
};

const UI = {
    show(id) {
        document.querySelectorAll('.panel').forEach(p => p.classList.remove('active'));
        if(id) document.getElementById(id).classList.add('active');
    },
    
    enter() {
        if(document.getElementById('p-pass').classList.contains('active')) App.verifyPass();
        else if(document.getElementById('p-login').classList.contains('active')) App.login();
    },

    setupHUD(lvl) {
        this.show(''); // Hide all
        document.getElementById('hud').style.display = 'block';
        document.getElementById('ui-zone').innerText = lvl.name;
        
        ['dash','shield','magnet','sonar'].forEach(k => {
            document.getElementById(`sk-${k}`).style.display = lvl.skills.includes(k) ? 'flex' : 'none';
        });
        this.updateHUD();
    },

    updateHUD() {
        document.getElementById('ui-size').innerText = Math.floor(Game.p.r);
        document.getElementById('ui-lives').innerText = Game.p.lives;
    },

    cd(k, val) {
        const max = CFG.SKILLS[k].cd;
        const el = document.getElementById(`cd-${k}`);
        el.style.height = (val/max)*100 + '%';
        const box = document.getElementById(`sk-${k}`);
        if(val<=0) box.classList.add('active'); else box.classList.remove('active');
    },

    floatText(txt, x, y, color) {
        if(x<0||x>Game.W||y<0||y>Game.H) return;
        const d = document.createElement('div');
        d.className = 'float-txt'; d.innerText = txt;
        d.style.left = x+'px'; d.style.top = y+'px'; d.style.color = color;
        document.getElementById('ui-layer').appendChild(d);
        setTimeout(()=>d.remove(), 1000);
    }
};

// åˆå§‹åŒ–
window.onload = function() {
    Game.init();
    UI.show('p-pass');
};
</script>
</body>
</html>
